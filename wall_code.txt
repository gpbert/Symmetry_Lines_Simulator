        // Wall class
        class Wall {
            constructor(ax, ay, bx, by, thickness = 200, height = 2700, groupId = null, floorId = 0) {
                // Points A and B ARE on the INTERNAL face (blue line - grid-aligned with columns)
                // The user draws on the grid lines, which become the internal face
                this.pointA = { x: ax, y: ay }; // Internal face point A (blue line, grid-aligned)
                this.pointB = { x: bx, y: by }; // Internal face point B (blue line, grid-aligned)
                this.thickness = thickness; // mm
                this.height = height; // mm
                this.groupId = groupId; // For tracking segments of the same wall
                this.floorId = floorId; // Which floor this wall belongs to
                this.updateVectors();
            }

            updateVectors() {
                // Direction vector d = AB
                this.d = {
                    x: this.pointB.x - this.pointA.x,
                    y: this.pointB.y - this.pointA.y
                };

                // Length
                this.length = Math.sqrt(this.d.x * this.d.x + this.d.y * this.d.y);

                // Normalized direction (handle zero-length case)
                if (this.length > 0) {
                    this.dNorm = {
                        x: this.d.x / this.length,
                        y: this.d.y / this.length
                    };
                } else {
                    // Default to horizontal for zero-length walls
                    this.dNorm = { x: 1, y: 0 };
                }

                // Normal vector n (perpendicular, pointing INWARD from external face)
                // Right-hand cross product: up Ã— d
                this.n = {
                    x: -this.dNorm.y,
                    y: this.dNorm.x
                };
            }

            getExternalFacePoints() {
                // External face is thickness distance outward from internal face (A and B)
                return {
                    a: {
                        x: this.pointA.x + this.n.x * this.thickness,
                        y: this.pointA.y + this.n.y * this.thickness
                    },
                    b: {
                        x: this.pointB.x + this.n.x * this.thickness,
                        y: this.pointB.y + this.n.y * this.thickness
                    }
                };
            }

            getInternalFacePoints() {
                // Internal face IS points A and B (for backward compatibility)
                return {
                    a: this.pointA,
                    b: this.pointB
                };
            }

            isParallelTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot > 0.999; // Almost parallel
            }

            isPerpendicularTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot < 0.1; // Almost perpendicular
            }

            sameOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot > 0.9;
            }

            oppositeOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot < -0.9;
            }

            overlapsInProjection(other) {
                // Project both walls onto the line direction
                const dir = this.dNorm;
                
                const a1 = this.pointA.x * dir.x + this.pointA.y * dir.y;
                const b1 = this.pointB.x * dir.x + this.pointB.y * dir.y;
                const min1 = Math.min(a1, b1);
                const max1 = Math.max(a1, b1);

                const a2 = other.pointA.x * dir.x + other.pointA.y * dir.y;
                const b2 = other.pointB.x * dir.x + other.pointB.y * dir.y;
                const min2 = Math.min(a2, b2);
                const max2 = Math.max(a2, b2);

                return !(max1 < min2 || max2 < min1);
            }

            distanceToWall(other) {
                // Calculate minimum distance between INTERNAL faces (blue lines - column face to column face)
                const internal1 = this.getInternalFacePoints();
                const internal2 = other.getInternalFacePoints();

                // Distance between the two internal faces (blue lines)
                const distances = [
                    this.pointToLineDistance(internal1.a, internal2.a, internal2.b),
                    this.pointToLineDistance(internal1.b, internal2.a, internal2.b),
                    this.pointToLineDistance(internal2.a, internal1.a, internal1.b),
                    this.pointToLineDistance(internal2.b, internal1.a, internal1.b)
                ];

                return Math.min(...distances);
            }

            pointToLineDistance(point, lineA, lineB) {
                const dx = lineB.x - lineA.x;
                const dy = lineB.y - lineA.y;
                const lenSq = dx * dx + dy * dy;
                
                if (lenSq === 0) return Math.sqrt(
                    (point.x - lineA.x) ** 2 + (point.y - lineA.y) ** 2
                );

                let t = ((point.x - lineA.x) * dx + (point.y - lineA.y) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));

                const projX = lineA.x + t * dx;
                const projY = lineA.y + t * dy;

                return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);
            }

            containsPoint(x, y, tolerance = 10) {
                const internal = this.getInternalFacePoints();
                
                // Check if point is within the wall rectangle (with tolerance)
                const dx = this.pointB.x - this.pointA.x;
                const dy = this.pointB.y - this.pointA.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = -dy / len;
                const ny = dx / len;

                // Create wall rectangle vertices
                const vertices = [
                    this.pointA,
                    this.pointB,
                    internal.b,
                    internal.a
                ];

                return this.isPointInPolygon({ x, y }, vertices, tolerance);
            }

            isPointInPolygon(point, vertices, tolerance) {
                let inside = false;
                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;
                    
                    const intersect = ((yi > point.y) !== (yj > point.y))
                        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                
                // Also check distance to edges
                for (let i = 0; i < vertices.length; i++) {
                    const j = (i + 1) % vertices.length;
                    const dist = this.pointToLineDistance(point, vertices[i], vertices[j]);
                    if (dist < tolerance) return true;
                }
                
                return inside;
            }
        }

        // Grid snapping - snap to 300mm external grid only
        function snapToGrid(value, gridSize = GRID_SIZE_EXTERNAL) {
            return Math.round(value / gridSize) * gridSize;
        }

        function mmToPx(mm) {
            return mm * MM_TO_PX;
        }

        function pxToMm(px) {
            return px / MM_TO_PX;
        }

        function pxSnapToGrid(px, gridSize = GRID_SIZE_EXTERNAL) {
            const mm = pxToMm(px);
            const snappedMm = snapToGrid(mm, gridSize);
            return mmToPx(snappedMm);
        }

        // Drawing functions
        function drawGrid() {
            const showGridCheckbox = document.getElementById('showGrid');
            if (showGridCheckbox && !showGridCheckbox.checked) {
                return;
            }

            const gridStepExternal = mmToPx(GRID_SIZE_EXTERNAL);
            const gridStepInternal = mmToPx(GRID_SIZE_INTERNAL);

            // Draw 300mm grid (external) - thicker, DARK lines
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2;
            for (let x = 0; x <= canvas.width; x += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= canvas.height; y += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw 100mm grid (internal) - lighter lines
            ctx.strokeStyle = '#dddddd';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= canvas.width; x += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(x % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= canvas.height; y += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(y % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function getRestrictedZones(wall) {
            // Only get zones for walls on current floor
            if (wall.floorId !== currentFloorId) {
                return [];
            }
            
            const zones = [];
            // Internal face is at points A and B (blue line)
            const internalY = wall.pointA.y;
            const internalX = wall.pointA.x;

            // Determine if wall is horizontal or vertical
            const isHorizontal = Math.abs(wall.d.y) < Math.abs(wall.d.x);

            // Use canvas dimensions to make zones "infinite"
            const canvasMaxX = pxToMm(canvas.width);
            const canvasMaxY = pxToMm(canvas.height);

            if (isHorizontal) {
                // Horizontal wall - restricted zones extend infinitely along X
                // Internal face is at A-B (y coordinate)

                // Zone away from internal face (opposite side - toward external face direction)
                const oppositeY = internalY + (wall.n.y > 0 ? MIN_DISTANCE_OPPOSITE : -MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: 0,
                    y1: Math.min(internalY, oppositeY),
                    x2: canvasMaxX,
                    y2: Math.max(internalY, oppositeY),
                    distance: MIN_DISTANCE_OPPOSITE
                });

                // Zone toward internal face (same side)
                const parallelY = internalY + (wall.n.y > 0 ? -MIN_DISTANCE_PARALLEL : MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: 0,
                    y1: Math.min(internalY, parallelY),
                    x2: canvasMaxX,
                    y2: Math.max(internalY, parallelY),
                    distance: MIN_DISTANCE_PARALLEL
                });
            } else {
                // Vertical wall - restricted zones extend infinitely along Y
                // Internal face is at A-B (x coordinate)

                // Zone away from internal face (opposite side - toward external face direction)
                const oppositeX = internalX + (wall.n.x > 0 ? MIN_DISTANCE_OPPOSITE : -MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: Math.min(internalX, oppositeX),
                    y1: 0,
                    x2: Math.max(internalX, oppositeX),
                    y2: canvasMaxY,
                    distance: MIN_DISTANCE_OPPOSITE
                });

                // Zone toward internal face (same side)
                const parallelX = internalX + (wall.n.x > 0 ? -MIN_DISTANCE_PARALLEL : MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: Math.min(internalX, parallelX),
                    y1: 0,
                    x2: Math.max(internalX, parallelX),
                    y2: canvasMaxY,
                    distance: MIN_DISTANCE_PARALLEL
                });
            }

            return zones;
        }

        function drawRestrictedZones() {
            if (!document.getElementById('showRestrictedZones').checked) return;
            
            walls.forEach(wall => {
                const zones = getRestrictedZones(wall);
                
                zones.forEach(zone => {
                    ctx.fillStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.1)' :  // Red for opposite (1200mm)
                        'rgba(255, 152, 0, 0.08)';   // Orange for parallel (600mm)
                    
                    ctx.fillRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );

                    // Draw border
                    ctx.strokeStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.3)' : 
                        'rgba(255, 152, 0, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.strokeRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );
                    ctx.setLineDash([]);
                });
            });
        }

        function isWallInRestrictedZone(newWall) {
            for (let existingWall of walls) {
                // Check if walls are perpendicular - no restriction
                if (existingWall.isPerpendicularTo(newWall)) {
                    continue;
                }

                // Check if parallel
                if (existingWall.isParallelTo(newWall)) {
                    const dist = newWall.distanceToWall(existingWall);
                    
                    // Use dot product to determine minimum distance
                    const dotProduct = newWall.n.x * existingWall.n.x + newWall.n.y * existingWall.n.y;
                    
                    let minDist;
                    if (dotProduct >= 0) {
                        // Same side: 600mm
                        minDist = MIN_DISTANCE_PARALLEL;
                    } else {
                        // Flipped - check if anti-parallel
                        if (dotProduct < -0.9) {
                            // Anti-parallel (opposite facing): 1200mm
                            minDist = MIN_DISTANCE_OPPOSITE;
                        } else {
                            // Parallel but not anti-parallel: 600mm
                            minDist = MIN_DISTANCE_PARALLEL;
                        }
                    }

                    if (dist < minDist) {
                        return { 
                            restricted: true, 
                            wall: existingWall, 
                            zone: { distance: minDist }
                        };
                    }
                }
            }
            return { restricted: false };
        }

        function drawWall(wall, isSelected = false, violations = [], opacity = 1.0, overrideColor = null) {
            const hasViolation = violations.length > 0;
            const external = wall.getExternalFacePoints();
            
            // Apply opacity for adjacent floor walls
            ctx.globalAlpha = opacity;

            // Draw wall body (from internal face A-B to external face)
            if (overrideColor) {
                ctx.fillStyle = overrideColor.replace(')', ', 0.15)').replace('rgb', 'rgba');
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? 'rgba(244, 67, 54, 0.2)' : 
                               isSelected ? 'rgba(33, 150, 243, 0.3)' : 'rgba(158, 158, 158, 0.3)';
                ctx.strokeStyle = hasViolation ? '#f44336' :
                                 isSelected ? '#2196F3' : '#757575';
            }
            ctx.lineWidth = isSelected ? 3 : 2;

            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw INTERNAL face line (BLUE - grid-aligned side with columns)
            // This is at points A and B
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = '#2196F3';
            }
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.stroke();

            // Draw external face line (thinner, darker)
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = hasViolation ? '#d32f2f' :
                                 isSelected ? '#1976D2' : '#424242';
            }
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.beginPath();
            ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.stroke();

            // Draw steel columns (10x10cm squares at A and B on the BLUE LINE)
            const columnSize = mmToPx(COLUMN_SIZE);
            if (overrideColor) {
                ctx.fillStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? '#f44336' :
                               isSelected ? '#2196F3' : '#616161';
            }

            // Column at A (on internal face - blue line)
            ctx.fillRect(
                mmToPx(wall.pointA.x) - columnSize / 2,
                mmToPx(wall.pointA.y) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Column at B (on internal face - blue line)
            ctx.fillRect(
                mmToPx(wall.pointB.x) - columnSize / 2,
                mmToPx(wall.pointB.y) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Draw dimensions
            if (isSelected) {
                const midX = (wall.pointA.x + wall.pointB.x) / 2;
                const midY = (wall.pointA.y + wall.pointB.y) / 2;
                
                ctx.fillStyle = '#2196F3';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `${Math.round(wall.length)}mm (${wall.thickness}mm thick)`,
                    mmToPx(midX),
                    mmToPx(midY) - 15
                );
            }
            
            // Reset global alpha
            ctx.globalAlpha = 1.0;
        }

        function draw() {
            console.log('draw() called');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();

            // Draw walls from adjacent floors first (if enabled)
            if (document.getElementById('showOtherFloors').checked) {
                walls.forEach((wall, idx) => {
                    // Draw walls from floor below
                    if (wall.floorId === currentFloorId - 1) {
                        drawWall(wall, false, [], 0.3, '#90A4AE'); // Light gray, semi-transparent
                    }
                    // Draw walls from floor above
                    else if (wall.floorId === currentFloorId + 1) {
                        drawWall(wall, false, [], 0.2, '#B0BEC5'); // Lighter gray, more transparent
                    }
                });
            }

            // Get current floor walls
            const currentFloorWalls = walls.filter(w => w.floorId === currentFloorId);

            // Draw restricted zones for current floor only
            if (currentFloorWalls.length > 0) {
                drawRestrictedZones();
            }

            // Get violations for current floor walls
            const wallViolations = new Map();
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId || 
                    wall.floorId === currentFloorId - 1 || 
                    wall.floorId === currentFloorId + 1) {
                    wallViolations.set(idx, validateWall(wall, idx));
                }
            });

            // Draw current floor walls
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId) {
                    const isSelected = wall === selectedWall;
                    const violations = wallViolations.get(idx) || [];
                    drawWall(wall, isSelected, violations);
                }
            });

            // Draw temporary wall while drawing
            if (drawingWall && tempPoint && (drawingWall.x !== tempPoint.x || drawingWall.y !== tempPoint.y)) {
                const tempWall = new Wall(
                    drawingWall.x,
                    drawingWall.y,
                    tempPoint.x,
                    tempPoint.y,
                    parseInt(document.getElementById('wallThickness').value),
                    parseInt(document.getElementById('wallHeight').value)
                );
                
                // Calculate wall segments if longer than MAX_WALL_LENGTH
                const wallSegments = [];
                if (tempWall.length > MAX_WALL_LENGTH) {
                    const numSegments = Math.ceil(tempWall.length / MAX_WALL_LENGTH);
                    const groupId = Date.now() + Math.random(); // Unique ID for preview segments
                    
                    for (let i = 0; i < numSegments; i++) {
                        const startRatio = i / numSegments;
                        const endRatio = (i + 1) / numSegments;
                        
                        const segStart = {
                            x: drawingWall.x + tempWall.d.x * startRatio,
                            y: drawingWall.y + tempWall.d.y * startRatio
                        };
                        const segEnd = {
                            x: drawingWall.x + tempWall.d.x * endRatio,
                            y: drawingWall.y + tempWall.d.y * endRatio
                        };
                        
                        wallSegments.push(new Wall(
                            segStart.x, segStart.y,
                            segEnd.x, segEnd.y,
                            tempWall.thickness,
                            tempWall.height,
                            groupId, // Assign the same groupId to all preview segments
                            currentFloorId // Preview on current floor
                        ));
                    }
                } else {
                    wallSegments.push(tempWall);
                }
                
                // Check if any segment is in restricted zone
                let isRestricted = false;
                let restriction = { restricted: false };
                for (let segment of wallSegments) {
                    const segRestriction = isWallInRestrictedZone(segment);
                    if (segRestriction.restricted) {
                        isRestricted = true;
                        restriction = segRestriction;
                        break;
                    }
                }
                
                // Draw each segment
                wallSegments.forEach((segment, idx) => {
                    const external = segment.getExternalFacePoints();
                
                    // Draw full wall preview (semi-transparent)
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.2)' : 'rgba(76, 175, 80, 0.2)';
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Draw INTERNAL face (BLUE - grid-aligned side with columns)
                    // This is at points A and B (the grid line)
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.stroke();

                    // Draw external face (dashed)
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw steel column previews at A and B (on the BLUE LINE)
                    const columnSize = mmToPx(COLUMN_SIZE);
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.5)' : 'rgba(76, 175, 80, 0.5)';
                    
                    // Column at A (on internal face - blue line)
                    ctx.fillRect(
                        mmToPx(segment.pointA.x) - columnSize / 2,
                        mmToPx(segment.pointA.y) - columnSize / 2,
                        columnSize,
                        columnSize
                    );
                    
                    // Column at B (on internal face - blue line)
                    ctx.fillRect(
                        mmToPx(segment.pointB.x) - columnSize / 2,
                        mmToPx(segment.pointB.y) - columnSize / 2,
                        columnSize,
                        columnSize
                    );

                    // Draw segment split markers if multiple segments
                    if (wallSegments.length > 1 && idx < wallSegments.length - 1) {
                        ctx.strokeStyle = '#FF9800';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([]);
                        const splitX = segment.pointB.x;
                        const splitY = segment.pointB.y;
                        
                        // Draw a small perpendicular line at the split
                        const perpLen = 20;
                        const perpX = -segment.dNorm.y * perpLen;
                        const perpY = segment.dNorm.x * perpLen;
                        
                        ctx.beginPath();
                        ctx.moveTo(mmToPx(splitX - perpX), mmToPx(splitY - perpY));
                        ctx.lineTo(mmToPx(splitX + perpX), mmToPx(splitY + perpY));
                        ctx.stroke();
                    }
                });

                // Draw start and end points
                ctx.fillStyle = isRestricted ? '#f44336' : '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(mmToPx(tempPoint.x), mmToPx(tempPoint.y), 6, 0, Math.PI * 2);
                ctx.fill();

                // Show info text
                const midX = (drawingWall.x + tempPoint.x) / 2;
                const midY = (drawingWall.y + tempPoint.y) / 2;
                
                ctx.fillStyle = isRestricted ? '#f44336' : '#4CAF50';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                
                if (isRestricted) {
                    ctx.fillText(
                        'âœ— Cannot place here',
                        mmToPx(midX),
                        mmToPx(midY) - 10
                    );
                    ctx.font = '12px sans-serif';
                    ctx.fillText(
                        `Min distance: ${restriction.zone.distance}mm`,
                        mmToPx(midX),
                        mmToPx(midY) + 10
                    );
                } else {
                    const totalLength = Math.round(tempWall.length);
                    if (wallSegments.length > 1) {
                        ctx.fillText(
                            `${totalLength}mm (${wallSegments.length} walls)`,
                            mmToPx(midX),
                            mmToPx(midY) - 10
                        );
                    } else {
                        ctx.fillText(
                            `${totalLength}mm`,
                            mmToPx(midX),
                            mmToPx(midY) - 10
                        );
                    }
                }
            }

            // Show starting point when first click is placed but no preview yet
            if (drawingWall && (!tempPoint || (drawingWall.x === tempPoint.x && drawingWall.y === tempPoint.y))) {
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw pulsing ring
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 12, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Show snap indicator when hovering and ready to start drawing
            if (currentMousePos && currentMode === 'draw' && !drawingWall) {
                drawSnapIndicator(currentMousePos.x, currentMousePos.y);
            }
        }

        // Validation functions
        function validateWall(wall, wallIndex) {
            const violations = [];

            // Check length
            if (wall.length < MIN_WALL_LENGTH) {
                violations.push({
                    type: 'error',
                    message: `Wall is too short (${Math.round(wall.length)}mm). Minimum: ${MIN_WALL_LENGTH}mm`
                });
            }

            if (wall.length > MAX_WALL_LENGTH) {
                violations.push({
                    type: 'error',
                    message: `Wall is too long (${Math.round(wall.length)}mm). Maximum: ${MAX_WALL_LENGTH}mm`
                });
            }

            // Check against other walls
            walls.forEach((otherWall, otherIndex) => {
                if (wallIndex === otherIndex) return;
                
                // Skip validation between segments of the same wall (auto-split)
                if (wall.groupId && wall.groupId === otherWall.groupId) return;
                
                // Determine if walls are on same floor or adjacent floors
                const onSameFloor = wall.floorId === otherWall.floorId;
                const onAdjacentFloors = Math.abs(wall.floorId - otherWall.floorId) === 1;

                // SAME FLOOR RULES
                if (onSameFloor) {
                    // Check if walls are parallel
                    if (wall.isParallelTo(otherWall)) {
                        const dist = wall.distanceToWall(otherWall);
                        
                        if (dist < 10) { // Aligned (on same line)
                            // Rule 1: Aligned walls cannot overlap and must share orientation and thickness
                            if (wall.overlapsInProjection(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls overlap with Wall ${otherIndex + 1}`
                                });
                            }

                            if (!wall.sameOrientation(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share orientation with Wall ${otherIndex + 1}`
                                });
                            }

                            if (wall.thickness !== otherWall.thickness) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share thickness with Wall ${otherIndex + 1}`
                                });
                            }
                        } else {
                            // Rule 3a: Parallel walls minimum distance
                            // Use dot product to determine orientation relationship
                            const dotProduct = wall.n.x * otherWall.n.x + wall.n.y * otherWall.n.y;
                            
                            let minDist;
                            if (dotProduct >= 0) {
                                // Same side (normals point in similar directions): 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            } else {
                                // Flipped - check if anti-parallel (opposite facing)
                                if (dotProduct < -0.9) {
                                    // Anti-parallel (opposite facing): 1200mm
                                    minDist = MIN_DISTANCE_OPPOSITE;
                                } else {
                                    // Parallel but not anti-parallel: 600mm
                                    minDist = MIN_DISTANCE_PARALLEL;
                                }
                            }

                            if (dist < minDist) {
                                violations.push({
                                type: 'error',
                                message: `Too close to Wall ${otherIndex + 1} (${Math.round(dist)}mm). Minimum: ${minDist}mm`
                            });
                        }
                    }
                }

                // Rule 3b: Perpendicular walls have no minimum distance requirement
                // (no violation to add)
            });

            return violations;
        }

        function validateAllWalls() {
            const allViolations = [];
            
            walls.forEach((wall, idx) => {
                const violations = validateWall(wall, idx);
                if (violations.length > 0) {
                    allViolations.push({
                        wallIndex: idx,
                        violations: violations
                    });
                }
            });

            displayViolations(allViolations);
            draw();
        }

        function displayViolations(allViolations) {
            const violationsList = document.getElementById('violationsList');
            
            if (allViolations.length === 0) {
                violationsList.innerHTML = '<div class="no-violations">âœ“ All rules satisfied!</div>';
                return;
            }

            let html = '';
            allViolations.forEach(({ wallIndex, violations }) => {
                violations.forEach(v => {
                    html += `
                        <div class="violation-item ${v.type}">
                            <div class="violation-title">Wall ${wallIndex + 1}: ${v.type.toUpperCase()}</div>
                            <div>${v.message}</div>
                        </div>
                    `;
                });
            });

            violationsList.innerHTML = html;
        }

        // Mouse handling
        let currentMousePos = null;

        function getMousePosition(e) {
            const rect = canvas.getBoundingClientRect();
            let x = pxToMm(e.clientX - rect.left);
            let y = pxToMm(e.clientY - rect.top);

            // Always snap to 300mm external grid
            x = snapToGrid(x, GRID_SIZE_EXTERNAL);
            y = snapToGrid(y, GRID_SIZE_EXTERNAL);

            return { x, y };
        }

        function drawSnapIndicator(x, y) {
            // Draw a small circle at snap point
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.arc(mmToPx(x), mmToPx(y), 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw crosshair
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 1;
            const size = 8;
            ctx.beginPath();
            ctx.moveTo(mmToPx(x) - size, mmToPx(y));
            ctx.lineTo(mmToPx(x) + size, mmToPx(y));
            ctx.moveTo(mmToPx(x), mmToPx(y) - size);
            ctx.lineTo(mmToPx(x), mmToPx(y) + size);
            ctx.stroke();
        }

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePosition(e);
            currentMousePos = pos;
            document.getElementById('mouseInfo').textContent = 
                `${Math.round(pos.x)}, ${Math.round(pos.y)} mm`;

            if (currentMode === 'draw' && drawingWall) {
                // Constrain to horizontal or vertical only
                const dx = Math.abs(pos.x - drawingWall.x);
                const dy = Math.abs(pos.y - drawingWall.y);
                
                if (dx > dy) {
                    // Horizontal wall
                    tempPoint = { x: pos.x, y: drawingWall.y };
                } else {
                    // Vertical wall
                    tempPoint = { x: drawingWall.x, y: pos.y };
                }
            }
            draw();
        });

        canvas.addEventListener('mouseleave', () => {
            currentMousePos = null;
            draw();
        });

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePosition(e);

            if (currentMode === 'draw') {
                if (!drawingWall) {
                    // Start drawing
                    drawingWall = pos;
                    tempPoint = pos;
                } else {
                    // Finish drawing
                    const thickness = parseInt(document.getElementById('wallThickness').value);
                    const height = 2700; // Default height
                    
                    // Constrain to horizontal or vertical
                    const dx = Math.abs(pos.x - drawingWall.x);
                    const dy = Math.abs(pos.y - drawingWall.y);
                    let finalPos = pos;
                    if (dx > dy) {
                        finalPos = { x: pos.x, y: drawingWall.y };
                    } else {
                        finalPos = { x: drawingWall.x, y: pos.y };
                    }
                    
                    const newWall = new Wall(
                        drawingWall.x,
                        drawingWall.y,
                        finalPos.x,
                        finalPos.y,
                        thickness,
                        height
                    );

                    if (newWall.length < MIN_WALL_LENGTH) {
                        alert(`Wall is too short. Minimum length is ${MIN_WALL_LENGTH}mm`);
                        drawingWall = null;
                        tempPoint = null;
                        draw();
                        return;
                    }

                    // Calculate wall segments if longer than MAX_WALL_LENGTH
                    const wallSegments = [];
                    if (newWall.length > MAX_WALL_LENGTH) {
                        const numSegments = Math.ceil(newWall.length / MAX_WALL_LENGTH);
                        const groupId = Date.now() + Math.random(); // Unique ID for this wall group
                        
                        for (let i = 0; i < numSegments; i++) {
                            const startRatio = i / numSegments;
                            const endRatio = (i + 1) / numSegments;
                            
                            const segStart = {
                                x: drawingWall.x + newWall.d.x * startRatio,
                                y: drawingWall.y + newWall.d.y * startRatio
                            };
                            const segEnd = {
                                x: drawingWall.x + newWall.d.x * endRatio,
                                y: drawingWall.y + newWall.d.y * endRatio
                            };
                            
                            wallSegments.push(new Wall(
                                segStart.x, segStart.y,
                                segEnd.x, segEnd.y,
                                thickness,
                                height,
                                groupId, // Assign the same groupId to all segments
                                currentFloorId // Assign to current floor
                            ));
                        }
                    } else {
                        wallSegments.push(newWall);
                    }

                    // Check if any segment is in restricted zone
                    for (let segment of wallSegments) {
                        const restriction = isWallInRestrictedZone(segment);
                        if (restriction.restricted) {
                            alert(`Cannot place wall here. Too close to existing wall.\nMinimum distance required: ${restriction.zone.distance}mm`);
                            drawingWall = null;
                            tempPoint = null;
                            draw();
                            return;
                        }
                    }

                    // Add all segments to walls array
                    wallSegments.forEach(segment => walls.push(segment));
                    
                    drawingWall = null;
                    tempPoint = null;
                    updateUI();
                    validateAllWalls();
                }
            } else if (currentMode === 'select') {
                // Find wall at click position (only on current floor)
                selectedWall = null;
                for (let i = walls.length - 1; i >= 0; i--) {
                    if (walls[i].floorId === currentFloorId && walls[i].containsPoint(pos.x, pos.y)) {
                        selectedWall = walls[i];
                        break;
                    }
                }
                updateUI();
                draw();
            }
        });

        // UI Event handlers
        document.getElementById('drawWallBtn').addEventListener('click', () => {
            currentMode = 'draw';
            drawingWall = null;
            tempPoint = null;
            updateModeUI();
        });

        document.getElementById('selectBtn').addEventListener('click', () => {
            currentMode = 'select';
            drawingWall = null;
            tempPoint = null;
            updateModeUI();
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedWall) {
                const index = walls.indexOf(selectedWall);
                if (index > -1) {
                    walls.splice(index, 1);
                    selectedWall = null;
                    updateUI();
                    validateAllWalls();
                }
            }
        });

        document.getElementById('clearAllBtn').addEventListener('click', () => {
            if (walls.length > 0 && confirm('Are you sure you want to clear all walls?')) {
                walls = [];
                selectedWall = null;
                drawingWall = null;
                tempPoint = null;
                updateUI();
                draw();
            }
        });

        document.getElementById('validateBtn').addEventListener('click', () => {
            validateAllWalls();
        });

        document.getElementById('showGrid').addEventListener('change', draw);
        document.getElementById('showRestrictedZones').addEventListener('change', draw);

        document.getElementById('wallThickness').addEventListener('change', () => {
            if (selectedWall) {
                selectedWall.thickness = parseInt(document.getElementById('wallThickness').value);
                selectedWall.updateVectors();
                draw();
                validateAllWalls();
            }
        });


        function updateModeUI() {
            document.querySelectorAll('.tool-buttons .btn-primary').forEach(btn => {
                btn.classList.remove('active');
            });

            if (currentMode === 'draw') {
                document.getElementById('drawWallBtn').classList.add('active');
                document.getElementById('modeInfo').textContent = 'Draw';
                canvas.style.cursor = 'crosshair';
            } else if (currentMode === 'select') {
                document.getElementById('selectBtn').classList.add('active');
                document.getElementById('modeInfo').textContent = 'Select';
                canvas.style.cursor = 'pointer';
            }
        }

        function updateUI() {
            document.getElementById('wallCount').textContent = walls.length;
            document.getElementById('selectedInfo').textContent = 
                selectedWall ? `Wall ${walls.indexOf(selectedWall) + 1}` : 'None';

            if (selectedWall) {
                document.getElementById('wallThickness').value = selectedWall.thickness;
                document.getElementById('wallHeight').value = selectedWall.height;
            }

            draw();
        }

        // Initialize
        updateModeUI();
        updateUI();
        
        // Show initial message
        document.getElementById('violationsList').innerHTML = 
            '<div class="no-violations">Draw walls to start. Click once for start point, move horizontally or vertically, then click for end point.</div>';
    </script>
</body>
</html>

