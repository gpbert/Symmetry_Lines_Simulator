<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>30cm Grid Simulator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
            display: flex;
            height: 100vh;
            overflow: hidden;
            color: #1a1a1a;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .sidebar {
            width: 240px;
            background: #ffffff;
            border-right: 1px solid #e8e8e8;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 2px 0 12px rgba(0, 0, 0, 0.02);
        }

        .sidebar-header {
            padding: 32px 24px;
            border-bottom: 1px solid #e8e8e8;
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
        }

        .sidebar-header h1 {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: -0.02em;
            color: #1a1a1a;
            margin-bottom: 6px;
        }

        .sidebar-header p {
            font-size: 12px;
            font-weight: 400;
            color: #6b6b6b;
            letter-spacing: 0;
        }

        .tools-section {
            padding: 24px;
            border-bottom: 1px solid #f0f0f0;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #8a8a8a;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .tool-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn {
            padding: 10px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            background: #ffffff;
            color: #2a2a2a;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
            letter-spacing: -0.01em;
        }

        .btn:hover {
            border-color: #d0d0d0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
        }

        .btn-primary {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            color: #ffffff;
            border-color: #1a1a1a;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%);
            border-color: #0a0a0a;
        }

        .btn-primary.active {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            box-shadow: 0 0 0 3px rgba(42, 42, 42, 0.1);
        }

        .btn-secondary {
            background: #ffffff;
            color: #4a4a4a;
            border-color: #e8e8e8;
        }

        .btn-secondary:hover {
            background: #fafafa;
            border-color: #d8d8d8;
        }

        .btn-danger {
            background: #ffffff;
            color: #d14343;
            border-color: #f0d0d0;
        }

        .btn-danger:hover {
            background: #fef5f5;
            border-color: #f0c0c0;
            color: #c13333;
        }

        .property-group {
            margin-bottom: 18px;
        }

        .property-group label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #5a5a5a;
            letter-spacing: -0.01em;
        }

        .property-group select,
        .property-group input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            background: #ffffff;
            color: #2a2a2a;
            transition: all 0.15s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
        }

        .property-group select:hover,
        .property-group input:hover {
            border-color: #d0d0d0;
        }

        .property-group select:focus,
        .property-group input:focus {
            outline: none;
            border-color: #a0a0a0;
            box-shadow: 0 0 0 3px rgba(42, 42, 42, 0.05);
        }

        .property-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
            accent-color: #2a2a2a;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #4a4a4a;
            cursor: pointer;
            transition: color 0.15s ease;
        }

        .checkbox-label:hover {
            color: #2a2a2a;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #fefefe 0%, #fafafa 100%);
        }

        canvas {
            cursor: crosshair;
            display: block;
        }

        .info-panel {
            position: absolute;
            top: 24px;
            right: 24px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.06);
            font-size: 12px;
            min-width: 200px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .info-label {
            color: #6b6b6b;
            margin-right: 16px;
            font-weight: 400;
        }

        .info-value {
            font-weight: 500;
            color: #2a2a2a;
            letter-spacing: -0.01em;
        }


        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal.show {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 820px;
            max-height: 85vh;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
            animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        @keyframes slideDown {
            from {
                transform: translateY(-30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 28px 32px;
            border-bottom: 1px solid #f0f0f0;
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
            border-radius: 12px 12px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            letter-spacing: -0.02em;
        }

        .modal-close {
            font-size: 28px;
            font-weight: 300;
            color: #8a8a8a;
            cursor: pointer;
            line-height: 1;
            transition: all 0.15s ease;
            padding: 4px;
        }

        .modal-close:hover {
            color: #2a2a2a;
            transform: scale(1.05);
        }

        .modal-body {
            padding: 32px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-intro {
            font-size: 13px;
            color: #5a5a5a;
            line-height: 1.6;
            margin-bottom: 28px;
            padding: 16px 18px;
            background: #fafafa;
            border-left: 2px solid #d0d0d0;
            border-radius: 6px;
        }

        .rule-section {
            margin-bottom: 24px;
            padding: 20px 22px;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #e8e8e8;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
        }

        .rule-section h3 {
            margin: 0 0 16px 0;
            color: #2a2a2a;
            font-size: 15px;
            font-weight: 600;
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 10px;
            letter-spacing: -0.01em;
        }

        .rule-section ul {
            margin: 0;
            padding-left: 20px;
            list-style-type: none;
        }

        .rule-section li {
            margin-bottom: 10px;
            line-height: 1.65;
            color: #4a4a4a;
            position: relative;
            font-size: 13px;
        }

        .rule-section li:before {
            content: "•";
            position: absolute;
            left: -14px;
            color: #b0b0b0;
            font-weight: normal;
        }

        .rule-section li strong {
            color: #2a2a2a;
            font-weight: 600;
        }

        .help-text {
            font-size: 11px;
            color: #8a8a8a;
            margin-top: 6px;
            line-height: 1.5;
        }

        /* Toast Messages */
        #toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            background: linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05);
            min-width: 300px;
            max-width: 400px;
            pointer-events: auto;
            animation: slideIn 0.3s ease-out;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .toast.error {
            border-left: 4px solid #f44336;
        }

        .toast.warning {
            border-left: 4px solid #ff9800;
        }

        .toast.info {
            border-left: 4px solid #2196f3;
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-message {
            color: #2a2a2a;
            font-size: 13px;
            line-height: 1.5;
            margin: 0;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .toast.hiding {
            animation: slideOut 0.3s ease-in forwards;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>30cm Grid Simulator</h1>
        </div>

        <div class="tools-section">
            <div class="section-title">Tools</div>
            <div class="tool-buttons">
                <button id="drawWallBtn" class="btn btn-primary">
                    ✏️ Draw Wall
                </button>
                <button id="selectBtn" class="btn btn-secondary">
                    👆 Select / Move
                </button>
                <button id="deleteBtn" class="btn btn-danger">
                    🗑️ Delete Selected
                </button>
                <button id="flipWallBtn" class="btn btn-secondary">
                    🔄 Flip Wall (Space)
                </button>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Level Management</div>
            <div class="property-group">
                <label for="currentFloor">Current Level</label>
                <select id="currentFloor">
                    <option value="0">Level 1</option>
                </select>
            </div>
            <div class="tool-buttons">
                <button id="addFloorBtn" class="btn btn-secondary">
                    ➕ Add Level Above
                </button>
                <button id="removeFloorBtn" class="btn btn-secondary">
                    ➖ Remove Current Level
                </button>
            </div>
            <div class="property-group" style="margin-top: 24px;">
                <label class="checkbox-label">
                    <input type="checkbox" id="showOtherFloors" checked>
                    Show Levels Below
                </label>
            </div>
            <div class="property-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showLevelsAbove" checked>
                    Show Levels Above
                </label>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Wall Properties</div>
            <div class="property-group">
                <label for="wallThickness">Thickness (cm)</label>
                <select id="wallThickness">
                    <option value="200">20 cm</option>
                    <option value="300">30 cm</option>
                </select>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Actions</div>
            <div class="tool-buttons">
                <button id="clearAllBtn" class="btn btn-secondary">
                    🔄 Clear All
                </button>
                <button id="showRulesBtn" class="btn btn-secondary">
                    📋 Positional Rules
                </button>
            </div>
        </div>

    </div>

    <div class="main-content">
        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <script>
        // Constants
        const GRID_SIZE_EXTERNAL = 300; // mm - 300mm grid external
        const GRID_SIZE_INTERNAL = 100; // mm - 100mm internal
        const MM_TO_PX = 0.15; // Scale factor for visualization (1mm = 0.15px)
        const COLUMN_SIZE = 100; // mm - 10x10cm steel column
        const MIN_WALL_LENGTH = 400; // mm
        const MIN_DISTANCE_PARALLEL = 600; // mm
        const MIN_DISTANCE_OPPOSITE = 1200; // mm

        // State
        let walls = [];
        let selectedWall = null;
        let currentMode = 'draw';
        let drawingWall = null;
        let tempPoint = null;
        let wallFlipped = false; // Track if wall is flipped during drawing
        
        // Undo history - stores operations (each operation can contain multiple walls)
        let history = [];
        const MAX_HISTORY = 50; // Keep last 50 operations
        
        // Level management
        let floors = [
            { id: 0, name: 'Level 1', height: 0 }
        ];
        let currentFloorId = 0;
        
        // Pan and Zoom state
        let panOffset = { x: 0, y: 0 };
        let zoomLevel = 1.0;
        let isPanning = false;
        let lastPanPos = { x: 0, y: 0 };
        
        // Move state
        let isDragging = false;
        let dragStartPos = null;
        let originalWallPos = null;

        // Toast notification system
        function showToast(message, type = 'error', duration = 4000) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icon = type === 'error' ? '❌' : type === 'warning' ? '⚠️' : 'ℹ️';
            
            toast.innerHTML = `
                <div class="toast-icon">${icon}</div>
                <div class="toast-content">
                    <p class="toast-message">${message}</p>
                </div>
            `;
            
            container.appendChild(toast);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.classList.add('hiding');
                setTimeout(() => {
                    container.removeChild(toast);
                }, 300); // Match animation duration
            }, duration);
            
            // Allow clicking to dismiss
            toast.addEventListener('click', () => {
                toast.classList.add('hiding');
                setTimeout(() => {
                    if (container.contains(toast)) {
                        container.removeChild(toast);
                    }
                }, 300);
            });
        }

        // Redo history
        let redoHistory = [];

        // Undo functionality
        function undo() {
            if (history.length === 0) {
                showToast('Nothing to undo', 'info', 2000);
                return;
            }
            
            // Get the last operation
            const lastOperation = history.pop();
            
            // Remove the walls from this operation
            lastOperation.wallIndices.forEach(index => {
                // Find and remove by comparing wall properties
                // (indices may have shifted, so we match by wall object)
                const wallIndex = walls.indexOf(lastOperation.walls[lastOperation.wallIndices.indexOf(index)]);
                if (wallIndex !== -1) {
                    walls.splice(wallIndex, 1);
                }
            });
            
            // Add to redo history
            redoHistory.push(lastOperation);
            if (redoHistory.length > MAX_HISTORY) {
                redoHistory.shift();
            }
            
            selectedWall = null;
            updateUI();
            draw();
            
            showToast('Undo', 'info', 2000);
        }

        // Redo functionality
        function redo() {
            if (redoHistory.length === 0) {
                showToast('Nothing to redo', 'info', 2000);
                return;
            }
            
            // Get the last undone operation
            const operation = redoHistory.pop();
            
            // Re-add the walls
            operation.walls.forEach(wall => {
                walls.push(wall);
            });
            
            // Add back to undo history
            addToHistory(operation.walls);
            
            selectedWall = null;
            updateUI();
            draw();
            
            showToast('Redo', 'info', 2000);
        }

        // Add walls to history
        function addToHistory(addedWalls) {
            const operation = {
                walls: [...addedWalls],
                wallIndices: addedWalls.map(w => walls.indexOf(w)),
                timestamp: Date.now()
            };
            
            history.push(operation);
            
            // Clear redo history when new action is performed
            redoHistory = [];
            
            // Limit history size
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
        }

        // Canvas variables
        let canvas, ctx;
        
        // Initialize everything when DOM is ready
        window.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            
            canvas = document.getElementById('mainCanvas');
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            ctx = canvas.getContext('2d');
            console.log('Canvas and context initialized');
            
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                if (canvas.width > 0 && canvas.height > 0) {
                    draw();
                } else {
                    console.error('Canvas has zero dimensions!');
                }
            }
            
            window.addEventListener('resize', resizeCanvas);
            
            // Give the browser time to layout the DOM
            setTimeout(() => {
                resizeCanvas();
                setupEventListeners();
            }, 100);
        });

        // Wall class
        class Wall {
            constructor(ax, ay, bx, by, thickness = 200, height = 2700, groupId = null, floorId = 0) {
                // Points A and B ARE on the INTERNAL face (blue line - grid-aligned with columns)
                // The user draws on the grid lines, which become the internal face
                this.pointA = { x: ax, y: ay }; // Internal face point A (blue line, grid-aligned)
                this.pointB = { x: bx, y: by }; // Internal face point B (blue line, grid-aligned)
                this.thickness = thickness; // mm
                this.height = height; // mm
                this.groupId = groupId; // For tracking segments of the same wall
                this.floorId = floorId; // Which floor this wall belongs to
                this.updateVectors();
            }

            updateVectors() {
                // Direction vector d = AB
                this.d = {
                    x: this.pointB.x - this.pointA.x,
                    y: this.pointB.y - this.pointA.y
                };

                // Length
                this.length = Math.sqrt(this.d.x * this.d.x + this.d.y * this.d.y);

                // Normalized direction (handle zero-length case)
                if (this.length > 0) {
                    this.dNorm = {
                        x: this.d.x / this.length,
                        y: this.d.y / this.length
                    };
                } else {
                    // Default to horizontal for zero-length walls
                    this.dNorm = { x: 1, y: 0 };
                }

                // Normal vector n (perpendicular, pointing INWARD from external face)
                // Right-hand cross product: up × d
                this.n = {
                    x: -this.dNorm.y,
                    y: this.dNorm.x
                };
            }

            getExternalFacePoints() {
                // External face is thickness distance outward from internal face (A and B)
                return {
                    a: {
                        x: this.pointA.x + this.n.x * this.thickness,
                        y: this.pointA.y + this.n.y * this.thickness
                    },
                    b: {
                        x: this.pointB.x + this.n.x * this.thickness,
                        y: this.pointB.y + this.n.y * this.thickness
                    }
                };
            }

            getInternalFacePoints() {
                // Internal face IS points A and B (for backward compatibility)
                return {
                    a: this.pointA,
                    b: this.pointB
                };
            }

            isParallelTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot > 0.999; // Almost parallel
            }

            isPerpendicularTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot < 0.1; // Almost perpendicular
            }

            sameOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot > 0.9;
            }

            oppositeOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot < -0.9;
            }

            overlapsInProjection(other) {
                // Project both walls onto the line direction
                const dir = this.dNorm;
                
                const a1 = this.pointA.x * dir.x + this.pointA.y * dir.y;
                const b1 = this.pointB.x * dir.x + this.pointB.y * dir.y;
                const min1 = Math.min(a1, b1);
                const max1 = Math.max(a1, b1);

                const a2 = other.pointA.x * dir.x + other.pointA.y * dir.y;
                const b2 = other.pointB.x * dir.x + other.pointB.y * dir.y;
                const min2 = Math.min(a2, b2);
                const max2 = Math.max(a2, b2);

                // Allow touching at endpoints (use <= to exclude touching walls)
                // Add small tolerance for floating point comparisons
                const tolerance = 1; // 1mm tolerance
                return !(max1 <= min2 + tolerance || max2 <= min1 + tolerance);
            }

            distanceToWall(other) {
                // Calculate minimum distance between INTERNAL faces (blue lines - column face to column face)
                // v3: Fixed to use infinite line distance for parallel walls - 2024
                
                // For parallel walls, calculate perpendicular distance between the infinite lines
                if (this.isParallelTo(other)) {
                    const internal1 = this.getInternalFacePoints();
                    const internal2 = other.getInternalFacePoints();
                    
                    // For parallel lines, perpendicular distance is constant everywhere
                    // Use cross product method: distance = |ax + by + c| / sqrt(a² + b²)
                    // Or simpler: use perpendicular vector
                    
                    // Get direction vector of wall 2
                    const dx = internal2.b.x - internal2.a.x;
                    const dy = internal2.b.y - internal2.a.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    
                    if (len === 0) {
                        return Math.sqrt(
                            (internal1.a.x - internal2.a.x) ** 2 + 
                            (internal1.a.y - internal2.a.y) ** 2
                        );
                    }
                    
                    // For parallel lines, use the cross product formula
                    // Distance = |cross product| / |direction vector|
                    // For 2D: |(x - x0) × direction| / |direction|
                    // = |dx * (py - y0) - dy * (px - x0)| / sqrt(dx² + dy²)
                    
                    const px = internal1.a.x;
                    const py = internal1.a.y;
                    const x0 = internal2.a.x;
                    const y0 = internal2.a.y;
                    
                    const crossProduct = Math.abs(dx * (py - y0) - dy * (px - x0));
                    const distance = crossProduct / len;
                    
                    console.log('DISTANCE CALC:', {
                        wall1_internal: {x: px, y: py},
                        wall2_internal: {x: x0, y: y0},
                        direction: {dx, dy},
                        crossProduct,
                        len,
                        distance: distance.toFixed(1)
                    });
                    
                    return distance;
                }
                
                // For non-parallel walls, calculate minimum distance between segments
                const internal1 = this.getInternalFacePoints();
                const internal2 = other.getInternalFacePoints();

                const distances = [
                    this.pointToLineDistance(internal1.a, internal2.a, internal2.b),
                    this.pointToLineDistance(internal1.b, internal2.a, internal2.b),
                    this.pointToLineDistance(internal2.a, internal1.a, internal1.b),
                    this.pointToLineDistance(internal2.b, internal1.a, internal1.b)
                ];

                return Math.min(...distances);
            }

            pointToLineDistance(point, lineA, lineB) {
                const dx = lineB.x - lineA.x;
                const dy = lineB.y - lineA.y;
                const lenSq = dx * dx + dy * dy;
                
                if (lenSq === 0) return Math.sqrt(
                    (point.x - lineA.x) ** 2 + (point.y - lineA.y) ** 2
                );

                let t = ((point.x - lineA.x) * dx + (point.y - lineA.y) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));

                const projX = lineA.x + t * dx;
                const projY = lineA.y + t * dy;

                return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);
            }

            containsPoint(x, y, tolerance = 10) {
                const internal = this.getInternalFacePoints();
                
                // Check if point is within the wall rectangle (with tolerance)
                const dx = this.pointB.x - this.pointA.x;
                const dy = this.pointB.y - this.pointA.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = -dy / len;
                const ny = dx / len;

                // Create wall rectangle vertices
                const vertices = [
                    this.pointA,
                    this.pointB,
                    internal.b,
                    internal.a
                ];

                return this.isPointInPolygon({ x, y }, vertices, tolerance);
            }

            isPointInPolygon(point, vertices, tolerance) {
                let inside = false;
                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;
                    
                    const intersect = ((yi > point.y) !== (yj > point.y))
                        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                
                // Also check distance to edges
                for (let i = 0; i < vertices.length; i++) {
                    const j = (i + 1) % vertices.length;
                    const dist = this.pointToLineDistance(point, vertices[i], vertices[j]);
                    if (dist < tolerance) return true;
                }
                
                return inside;
            }
        }

        // Grid snapping - snap to 300mm external grid only
        function snapToGrid(value, gridSize = GRID_SIZE_EXTERNAL) {
            return Math.round(value / gridSize) * gridSize;
        }

        function mmToPx(mm) {
            return mm * MM_TO_PX;
        }

        function pxToMm(px) {
            return px / MM_TO_PX;
        }

        function pxSnapToGrid(px, gridSize = GRID_SIZE_EXTERNAL) {
            const mm = pxToMm(px);
            const snappedMm = snapToGrid(mm, gridSize);
            return mmToPx(snappedMm);
        }

        // Drawing functions
        function drawGrid() {
            if (!ctx || !canvas) {
                console.error('Canvas not initialized in drawGrid!');
                return;
            }
            
            // Grid is always shown
            
            const gridStepExternal = mmToPx(GRID_SIZE_EXTERNAL);
            const gridStepInternal = mmToPx(GRID_SIZE_INTERNAL);

            // Calculate visible world bounds (in pixels) accounting for pan/zoom
            const visibleLeft = -panOffset.x / zoomLevel;
            const visibleTop = -panOffset.y / zoomLevel;
            const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
            const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
            
            // Round to grid boundaries
            const startX = Math.floor(visibleLeft / gridStepExternal) * gridStepExternal;
            const endX = Math.ceil(visibleRight / gridStepExternal) * gridStepExternal;
            const startY = Math.floor(visibleTop / gridStepExternal) * gridStepExternal;
            const endY = Math.ceil(visibleBottom / gridStepExternal) * gridStepExternal;

            // Draw 300mm grid (external) - DARK, thicker lines
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2 / zoomLevel; // Adjust line width for zoom
            for (let x = startX; x <= endX; x += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(x, visibleTop);
                ctx.lineTo(x, visibleBottom);
                ctx.stroke();
            }
            for (let y = startY; y <= endY; y += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(visibleLeft, y);
                ctx.lineTo(visibleRight, y);
                ctx.stroke();
            }

            // Draw 100mm grid (internal) - lighter lines
            ctx.strokeStyle = '#dddddd';
            ctx.lineWidth = 0.5 / zoomLevel; // Adjust line width for zoom
            
            const startXInternal = Math.floor(visibleLeft / gridStepInternal) * gridStepInternal;
            const endXInternal = Math.ceil(visibleRight / gridStepInternal) * gridStepInternal;
            const startYInternal = Math.floor(visibleTop / gridStepInternal) * gridStepInternal;
            const endYInternal = Math.ceil(visibleBottom / gridStepInternal) * gridStepInternal;
            
            for (let x = startXInternal; x <= endXInternal; x += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(x % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(x, visibleTop);
                ctx.lineTo(x, visibleBottom);
                ctx.stroke();
            }
            for (let y = startYInternal; y <= endYInternal; y += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(y % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(visibleLeft, y);
                ctx.lineTo(visibleRight, y);
                ctx.stroke();
            }
        }

        function getRestrictedZones(wall) {
            // Show restricted zones from all floors on the current floor
            const zones = [];
            // Internal face is at points A and B (blue line)
            const internalY = wall.pointA.y;
            const internalX = wall.pointA.x;

            // Determine if wall is horizontal or vertical
            const isHorizontal = Math.abs(wall.d.y) < Math.abs(wall.d.x);

            // Calculate truly infinite bounds based on visible area + large margin
            const visibleLeft = -panOffset.x / zoomLevel;
            const visibleTop = -panOffset.y / zoomLevel;
            const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
            const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
            
            // Add large margin to make zones effectively infinite
            const margin = 100000; // 100 meters in pixels
            const infiniteLeft = pxToMm(visibleLeft - margin);
            const infiniteRight = pxToMm(visibleRight + margin);
            const infiniteTop = pxToMm(visibleTop - margin);
            const infiniteBottom = pxToMm(visibleBottom + margin);

            if (isHorizontal) {
                // Horizontal wall - restricted zones extend infinitely along X
                // Internal face is at A-B (y coordinate)
                // Normal vector n points INWARD from external face

                // Zone on internal side (same orientation - toward internal face, direction of n)
                // Same-orientation walls need 600mm clearance on this side
                const parallelY = internalY + (wall.n.y > 0 ? MIN_DISTANCE_PARALLEL : -MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: infiniteLeft,
                    y1: Math.min(internalY, parallelY),
                    x2: infiniteRight,
                    y2: Math.max(internalY, parallelY),
                    distance: MIN_DISTANCE_PARALLEL
                });

                // Zone on external side (opposite orientation - away from internal face, opposite to n)
                // Opposite-orientation walls need 1200mm clearance on this side
                const oppositeY = internalY + (wall.n.y > 0 ? -MIN_DISTANCE_OPPOSITE : MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: infiniteLeft,
                    y1: Math.min(internalY, oppositeY),
                    x2: infiniteRight,
                    y2: Math.max(internalY, oppositeY),
                    distance: MIN_DISTANCE_OPPOSITE
                });
            } else {
                // Vertical wall - restricted zones extend infinitely along Y
                // Internal face is at A-B (x coordinate)
                // Normal vector n points INWARD from external face

                // Zone on internal side (same orientation - toward internal face, direction of n)
                // Same-orientation walls need 600mm clearance on this side
                const parallelX = internalX + (wall.n.x > 0 ? MIN_DISTANCE_PARALLEL : -MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: Math.min(internalX, parallelX),
                    y1: infiniteTop,
                    x2: Math.max(internalX, parallelX),
                    y2: infiniteBottom,
                    distance: MIN_DISTANCE_PARALLEL
                });

                // Zone on external side (opposite orientation - away from internal face, opposite to n)
                // Opposite-orientation walls need 1200mm clearance on this side
                const oppositeX = internalX + (wall.n.x > 0 ? -MIN_DISTANCE_OPPOSITE : MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: Math.min(internalX, oppositeX),
                    y1: infiniteTop,
                    x2: Math.max(internalX, oppositeX),
                    y2: infiniteBottom,
                    distance: MIN_DISTANCE_OPPOSITE
                });
            }

            return zones;
        }

        function drawRestrictedZones() {
            // Restricted zones are always shown
            
            walls.forEach(wall => {
                const zones = getRestrictedZones(wall);
                
                zones.forEach(zone => {
                    ctx.fillStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.1)' :  // Red for opposite (1200mm)
                        'rgba(255, 152, 0, 0.08)';   // Orange for parallel (600mm)
                    
                    ctx.fillRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );

                    // Draw border
                    ctx.strokeStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.3)' : 
                        'rgba(255, 152, 0, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.strokeRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );
                    ctx.setLineDash([]);
                });
            });
        }

        function isWallInRestrictedZone(newWall) {
            for (let existingWall of walls) {
                const onSameFloor = newWall.floorId === existingWall.floorId;
                const onDifferentFloor = newWall.floorId !== existingWall.floorId;
                
                // Check if walls are perpendicular - no restriction
                if (existingWall.isPerpendicularTo(newWall)) {
                    continue;
                }

                // Check if parallel
                if (existingWall.isParallelTo(newWall)) {
                    const dist = newWall.distanceToWall(existingWall);
                    
                    // Aligned walls (on same line)
                    if (dist < 10) {
                        const sameOrientation = newWall.sameOrientation(existingWall);
                        const sameThickness = Math.abs(newWall.thickness - existingWall.thickness) < 1;
                        const hasOverlap = newWall.overlapsInProjection(existingWall);
                        
                        if (onSameFloor) {
                            // Rule 1: Aligned walls on same floor must share orientation and thickness
                            if (!sameOrientation || !sameThickness) {
                                return {
                                    restricted: true,
                                    wall: existingWall,
                                    zone: { distance: 1200, reason: 'Same-floor aligned walls must share orientation and thickness' }
                                };
                            }
                            // Also can't overlap
                            if (hasOverlap) {
                                return {
                                    restricted: true,
                                    wall: existingWall,
                                    zone: { distance: 0, reason: 'Same-floor aligned walls cannot overlap' }
                                };
                            }
                        } else if (hasOverlap) {
                            // Rule 2: Cross-floor overlapping walls must share orientation and thickness
                            if (!sameOrientation || !sameThickness) {
                                return {
                                    restricted: true,
                                    wall: existingWall,
                                    zone: { distance: 0, reason: 'Cross-floor overlap requires matching thickness and orientation' }
                                };
                            }
                        }
                        
                        // If we got here, the rules are satisfied
                        continue;
                    }
                    
                    // Non-aligned parallel walls on same floor OR adjacent floors need minimum distance (Rule 3)
                    const floorDiff = Math.abs(newWall.floorId - existingWall.floorId);
                    if (floorDiff <= 1) { // Same floor or adjacent floors (consecutive levels)
                        // Determine minimum distance based on orientation
                        let minDist;
                        if (newWall.oppositeOrientation(existingWall)) {
                            // Opposite orientation: check if facing toward/away
                            const newWallMidX = (newWall.pointA.x + newWall.pointB.x) / 2;
                            const newWallMidY = (newWall.pointA.y + newWall.pointB.y) / 2;
                            const existingWallMidX = (existingWall.pointA.x + existingWall.pointB.x) / 2;
                            const existingWallMidY = (existingWall.pointA.y + existingWall.pointB.y) / 2;
                            
                            const toNewWall = {
                                x: newWallMidX - existingWallMidX,
                                y: newWallMidY - existingWallMidY
                            };
                            
                            const existingToNew = toNewWall.x * existingWall.n.x + toNewWall.y * existingWall.n.y;
                            
                            if (existingToNew > 0) {
                                // Internal faces facing each other: 1200mm
                                minDist = MIN_DISTANCE_OPPOSITE;
                            } else {
                                // Internal faces facing away from each other: 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            }
                        } else {
                            // Same orientation: 600mm
                            minDist = MIN_DISTANCE_PARALLEL;
                        }

                        // Add 2mm tolerance to avoid floating-point precision issues
                        if (dist < minDist - 2) {
                            return { 
                                restricted: true, 
                                wall: existingWall, 
                                zone: { distance: minDist }
                            };
                        }
                    }
                }
            }
            return { restricted: false };
        }

        function drawWall(wall, isSelected = false, violations = [], opacity = 1.0, overrideColor = null) {
            const hasViolation = violations.length > 0;
            const external = wall.getExternalFacePoints();
            
            // Apply opacity for adjacent floor walls
            ctx.globalAlpha = opacity;

            // Draw wall body (from internal face A-B to external face)
            if (overrideColor) {
                ctx.fillStyle = overrideColor.replace(')', ', 0.15)').replace('rgb', 'rgba');
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? 'rgba(244, 67, 54, 0.2)' : 
                               isSelected ? 'rgba(33, 150, 243, 0.3)' : 'rgba(158, 158, 158, 0.3)';
                ctx.strokeStyle = hasViolation ? '#f44336' :
                                 isSelected ? '#2196F3' : '#757575';
            }
            ctx.lineWidth = isSelected ? 3 : 2;

            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw INTERNAL face line (BLUE - grid-aligned side with columns)
            // This is at points A and B
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = '#2196F3';
            }
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.stroke();

            // Draw external face line (thinner, darker)
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = hasViolation ? '#d32f2f' :
                                 isSelected ? '#1976D2' : '#424242';
            }
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.beginPath();
            ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.stroke();

            // Draw steel columns (10x10cm squares at A and B on the BLUE LINE)
            const columnSize = mmToPx(COLUMN_SIZE);
            if (overrideColor) {
                ctx.fillStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? '#f44336' :
                               isSelected ? '#2196F3' : '#616161';
            }

            // Column at A (on internal face - blue line)
            // Position column in grid cell, aligned to internal corner
            // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
            const colAX = wall.pointA.x + (COLUMN_SIZE / 2) * wall.dNorm.x + (COLUMN_SIZE / 2) * wall.n.x;
            const colAY = wall.pointA.y + (COLUMN_SIZE / 2) * wall.dNorm.y + (COLUMN_SIZE / 2) * wall.n.y;
            ctx.fillRect(
                mmToPx(colAX) - columnSize / 2,
                mmToPx(colAY) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Column at B (on internal face - blue line)
            // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
            const colBX = wall.pointB.x - (COLUMN_SIZE / 2) * wall.dNorm.x + (COLUMN_SIZE / 2) * wall.n.x;
            const colBY = wall.pointB.y - (COLUMN_SIZE / 2) * wall.dNorm.y + (COLUMN_SIZE / 2) * wall.n.y;
            ctx.fillRect(
                mmToPx(colBX) - columnSize / 2,
                mmToPx(colBY) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Draw dimensions
            if (isSelected) {
                const midX = (wall.pointA.x + wall.pointB.x) / 2;
                const midY = (wall.pointA.y + wall.pointB.y) / 2;
                
                ctx.fillStyle = '#2196F3';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `${Math.round(wall.length / 10)}cm (${wall.thickness / 10}cm thick)`,
                    mmToPx(midX),
                    mmToPx(midY) - 15
                );
            }
            
            // Reset global alpha
            ctx.globalAlpha = 1.0;
        }

        function draw() {
            console.log('draw() called');
            
            if (!ctx || !canvas) {
                console.error('Canvas not initialized in draw!');
                return;
            }
            
            console.log('Drawing on canvas:', canvas.width, 'x', canvas.height);
            
            // Clear and fill background (before transformation)
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply pan and zoom transformation
            ctx.setTransform(zoomLevel, 0, 0, zoomLevel, panOffset.x, panOffset.y);
            
            drawGrid();

            // Draw walls from levels below if enabled
            if (document.getElementById('showOtherFloors').checked) {
                walls.forEach((wall, idx) => {
                    // Only show levels below the current level
                    if (wall.floorId < currentFloorId) {
                        // Calculate opacity based on distance from current level
                        // 1 level below = 0.4 opacity, 2 levels = 0.25, 3 levels = 0.15, etc.
                        const floorsBelow = currentFloorId - wall.floorId;
                        const opacity = Math.max(0.1, 0.5 - (floorsBelow * 0.15));
                        
                        // Lighter gray color for trace
                        drawWall(wall, false, [], opacity, '#90A4AE');
                    }
                });
            }
            
            // Draw walls from levels above if enabled (draw early so they don't get covered)
            const showLevelsAboveCheckbox = document.getElementById('showLevelsAbove');
            if (showLevelsAboveCheckbox && showLevelsAboveCheckbox.checked) {
                walls.forEach((wall, idx) => {
                    // Only show levels above the current level
                    if (wall.floorId > currentFloorId) {
                        // Calculate opacity based on distance from current level
                        const floorsAbove = wall.floorId - currentFloorId;
                        
                        // Get wall faces
                        const external = wall.getExternalFacePoints();
                        
                        // Draw filled rectangle with very faint light grey
                        // Use much lower opacity for fill (0.15 for 1 level above)
                        const fillOpacity = Math.max(0.08, 0.15 - (floorsAbove * 0.04));
                        ctx.globalAlpha = fillOpacity;
                        ctx.fillStyle = '#B0BEC5'; // Light blue-grey fill
                        
                        ctx.beginPath();
                        ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
                        ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
                        ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                        ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw dashed outline with higher opacity for visibility
                        const outlineOpacity = Math.max(0.2, 0.4 - (floorsAbove * 0.1));
                        ctx.globalAlpha = outlineOpacity;
                        ctx.strokeStyle = '#607D8B'; // Darker blue-grey outline
                        ctx.lineWidth = 2 / zoomLevel;
                        ctx.setLineDash([8 / zoomLevel, 8 / zoomLevel]);
                        ctx.stroke();
                        
                        ctx.setLineDash([]);
                        ctx.globalAlpha = 1.0;
                    }
                });
            }
            
            // Get current level walls
            const currentFloorWalls = walls.filter(w => w.floorId === currentFloorId);

            // Get violations for current level walls
            const wallViolations = new Map();
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId || 
                    wall.floorId === currentFloorId - 1 || 
                    wall.floorId === currentFloorId + 1) {
                    wallViolations.set(idx, validateWall(wall, idx));
                }
            });

            // Draw current level walls
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId) {
                    const isSelected = wall === selectedWall;
                    const violations = wallViolations.get(idx) || [];
                    drawWall(wall, isSelected, violations);
                }
            });

            // Draw temporary wall while drawing
            if (drawingWall && tempPoint && (drawingWall.x !== tempPoint.x || drawingWall.y !== tempPoint.y)) {
                // Apply flip by swapping start/end if flipped
                const startX = wallFlipped ? tempPoint.x : drawingWall.x;
                const startY = wallFlipped ? tempPoint.y : drawingWall.y;
                const endX = wallFlipped ? drawingWall.x : tempPoint.x;
                const endY = wallFlipped ? drawingWall.y : tempPoint.y;
                
                const tempWall = new Wall(
                    startX,
                    startY,
                    endX,
                    endY,
                    parseInt(document.getElementById('wallThickness').value),
                    2700, // Default height
                    null, // No groupId for preview
                    currentFloorId // Preview on current floor
                );
                
                // Draw dynamic restriction zones based on preview wall's orientation
                if (tempWall.length > 0) {
                    walls.forEach((existingWall, idx) => {
                        console.log(`Wall ${idx}: ${existingWall.pointA.x},${existingWall.pointA.y} to ${existingWall.pointB.x},${existingWall.pointB.y}`);
                        
                        // Check walls on current floor and adjacent floors (consecutive levels)
                        const floorDiff = Math.abs(existingWall.floorId - currentFloorId);
                        if (floorDiff > 1) {
                            console.log('  -> Skip: not on current or adjacent floor');
                            return;
                        }
                        
                        // Only draw zones for parallel walls
                        const isParallel = existingWall.isParallelTo(tempWall);
                        console.log('  -> Parallel:', isParallel);
                        if (!isParallel) return;
                        
                        // Calculate preview midpoint (used for both special case and general case)
                        const previewMidX = (tempWall.pointA.x + tempWall.pointB.x) / 2;
                        const previewMidY = (tempWall.pointA.y + tempWall.pointB.y) / 2;
                        
                        // Check if walls are aligned (same line AND same orientation)
                        const dist = tempWall.distanceToWall(existingWall);
                        console.log('  -> Distance:', dist.toFixed(1) + 'mm');
                        if (dist < 10) {
                            // On same line - check orientation
                            const sameOrientation = tempWall.sameOrientation(existingWall);
                            console.log('  -> Same orientation:', sameOrientation);
                            if (sameOrientation) {
                                console.log('  -> Skip: truly aligned (same line + same orientation)');
                                return;
                            }
                            // Same line but OPPOSITE orientation - INVALID! Always show zone
                            console.log('  -> Same line + opposite orientation = ALWAYS INVALID');
                            // This is always invalid, so show zone extending from the existing wall
                            const requiredDistance = MIN_DISTANCE_OPPOSITE; // 1200mm for opposite orientation
                            
                            ctx.fillStyle = 'rgba(244, 67, 54, 0.12)'; // Red
                            
                            const isHorizontal = Math.abs(existingWall.d.y) < Math.abs(existingWall.d.x);
                            const internalY = existingWall.pointA.y;
                            const internalX = existingWall.pointA.x;
                            
                            const visibleLeft = (-panOffset.x) / zoomLevel;
                            const visibleTop = (-panOffset.y) / zoomLevel;
                            const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
                            const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
                            const margin = 100000;
                            const infiniteLeft = pxToMm(visibleLeft - margin);
                            const infiniteRight = pxToMm(visibleRight + margin);
                            const infiniteTop = pxToMm(visibleTop - margin);
                            const infiniteBottom = pxToMm(visibleBottom + margin);
                            
                            if (isHorizontal) {
                                // Determine if preview is above or below existing wall
                                if (previewMidY > internalY) {
                                    // Preview is below - draw zone below
                                    ctx.fillRect(
                                        mmToPx(infiniteLeft),
                                        mmToPx(internalY),
                                        mmToPx(infiniteRight - infiniteLeft),
                                        mmToPx(requiredDistance)
                                    );
                                } else {
                                    // Preview is above - draw zone above
                                    ctx.fillRect(
                                        mmToPx(infiniteLeft),
                                        mmToPx(internalY - requiredDistance),
                                        mmToPx(infiniteRight - infiniteLeft),
                                        mmToPx(requiredDistance)
                                    );
                                }
                            } else {
                                // Determine if preview is left or right of existing wall
                                if (previewMidX > internalX) {
                                    // Preview is to the right - draw zone right
                                    ctx.fillRect(
                                        mmToPx(internalX),
                                        mmToPx(infiniteTop),
                                        mmToPx(requiredDistance),
                                        mmToPx(infiniteBottom - infiniteTop)
                                    );
                                } else {
                                    // Preview is to the left - draw zone left
                                    ctx.fillRect(
                                        mmToPx(internalX - requiredDistance),
                                        mmToPx(infiniteTop),
                                        mmToPx(requiredDistance),
                                        mmToPx(infiniteBottom - infiniteTop)
                                    );
                                }
                            }
                            return; // Done drawing zone for this wall
                        }
                        
                        // Determine which side of the existing wall the preview wall is on
                        // (previewMidX/Y already calculated above)
                        
                        // Vector from existing wall's internal face to preview wall midpoint
                        const toPreview = {
                            x: previewMidX - existingWall.pointA.x,
                            y: previewMidY - existingWall.pointA.y
                        };
                        
                        // Skip if walls are perpendicular (no parallel distance rule)
                        if (!tempWall.isParallelTo(existingWall)) {
                            return;
                        }
                        
                        // Skip if walls are aligned (on same line) - aligned walls are allowed
                        const distanceAtoLine = tempWall.pointToLineDistance(
                            tempWall.pointA, existingWall.pointA, existingWall.pointB
                        );
                        if (distanceAtoLine < 1) { // Aligned (within 1mm tolerance)
                            return;
                        }
                        
                        // Calculate actual distance between walls
                        const actualDistance = tempWall.distanceToWall(existingWall);
                        
                        // Determine the required distance based on orientation
                        const orientationDot = tempWall.n.x * existingWall.n.x + tempWall.n.y * existingWall.n.y;
                        let requiredDistance;
                        
                        // Check if walls have opposite normals
                        if (orientationDot < -0.9) {
                            // Walls are anti-parallel. Now check if internal faces are facing TOWARD each other
                            // Vector from existing wall to preview wall
                            const toPreviewWall = {
                                x: previewMidX - existingWall.pointA.x,
                                y: previewMidY - existingWall.pointA.y
                            };
                            
                            // If existing wall's normal points toward preview (dot > 0), 
                            // and preview wall's normal points toward existing (opposite direction),
                            // then internal faces are facing each other = 1200mm rule
                            const existingToPreview = toPreviewWall.x * existingWall.n.x + toPreviewWall.y * existingWall.n.y;
                            
                            if (existingToPreview > 0) {
                                // Internal faces facing each other: 1200mm
                                requiredDistance = MIN_DISTANCE_OPPOSITE;
                            } else {
                                // Internal faces facing away from each other: 600mm
                                requiredDistance = MIN_DISTANCE_PARALLEL;
                            }
                        } else {
                            // Same orientation or not truly anti-parallel: 600mm
                            requiredDistance = MIN_DISTANCE_PARALLEL;
                        }
                        
                        // Only show zone if preview wall would violate the distance rule
                        // Add 2mm tolerance to match validation logic
                        if (actualDistance >= requiredDistance - 2) {
                            return; // Skip this wall - no violation risk
                        }
                        
                        // All zones are RED
                        const zoneColor = 'rgba(244, 67, 54, 0.12)';
                        
                        // Calculate truly infinite bounds
                        const visibleLeft = -panOffset.x / zoomLevel;
                        const visibleTop = -panOffset.y / zoomLevel;
                        const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
                        const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
                        const margin = 100000;
                        const infiniteLeft = pxToMm(visibleLeft - margin);
                        const infiniteRight = pxToMm(visibleRight + margin);
                        const infiniteTop = pxToMm(visibleTop - margin);
                        const infiniteBottom = pxToMm(visibleBottom + margin);
                        
                        // Determine which side of the existing wall the preview is on
                        // using the normal vector of the existing wall
                        const sideDot = toPreview.x * existingWall.n.x + toPreview.y * existingWall.n.y;
                        
                        // sideDot > 0: preview is on the internal side (direction of normal)
                        // sideDot < 0: preview is on the external side (opposite to normal)
                        
                        const isHorizontal = Math.abs(existingWall.d.y) < Math.abs(existingWall.d.x);
                        
                        ctx.fillStyle = zoneColor;
                        
                        if (isHorizontal) {
                            // Horizontal wall - zone extends vertically
                            // Internal face is at pointA.y
                            // Normal points perpendicular to the wall (up or down)
                            const internalY = existingWall.pointA.y;
                            
                            // Determine zone direction based on where preview is relative to internal face
                            // For horizontal walls, check if preview is above or below
                            if (previewMidY > internalY) {
                                // Preview is below internal face - zone extends downward
                                ctx.fillRect(
                                    mmToPx(infiniteLeft),
                                    mmToPx(internalY),
                                    mmToPx(infiniteRight - infiniteLeft),
                                    mmToPx(requiredDistance)
                                );
                            } else {
                                // Preview is above internal face - zone extends upward
                                ctx.fillRect(
                                    mmToPx(infiniteLeft),
                                    mmToPx(internalY - requiredDistance),
                                    mmToPx(infiniteRight - infiniteLeft),
                                    mmToPx(requiredDistance)
                                );
                            }
                        } else {
                            // Vertical wall - zone extends horizontally
                            // Internal face is at pointA.x
                            // Normal points perpendicular to the wall (left or right)
                            const internalX = existingWall.pointA.x;
                            
                            // Determine zone direction based on where preview is relative to internal face
                            // For vertical walls, check if preview is left or right
                            if (previewMidX > internalX) {
                                // Preview is to the right of internal face - zone extends right
                                ctx.fillRect(
                                    mmToPx(internalX),
                                    mmToPx(infiniteTop),
                                    mmToPx(requiredDistance),
                                    mmToPx(infiniteBottom - infiniteTop)
                                );
                            } else {
                                // Preview is to the left of internal face - zone extends left
                                ctx.fillRect(
                                    mmToPx(internalX - requiredDistance),
                                    mmToPx(infiniteTop),
                                    mmToPx(requiredDistance),
                                    mmToPx(infiniteBottom - infiniteTop)
                                );
                            }
                        }
                    });
                }
                
                // Check if wall is in restricted zone
                const restriction = isWallInRestrictedZone(tempWall);
                const isRestricted = restriction.restricted;
                
                // Draw the preview wall
                {
                    const segment = tempWall;
                    const external = segment.getExternalFacePoints();
                
                    // Draw full wall preview (semi-transparent)
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.2)' : 'rgba(76, 175, 80, 0.2)';
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Draw INTERNAL face (BLUE - grid-aligned side with columns)
                    // This is at points A and B (the grid line)
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.stroke();

                    // Draw external face (dashed)
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw steel column previews at A and B (on the BLUE LINE)
                    const columnSize = mmToPx(COLUMN_SIZE);
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.5)' : 'rgba(76, 175, 80, 0.5)';
                    
                    // Column at A (on internal face - blue line)
                    // Position column in grid cell, aligned to internal corner
                    // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
                    const colAX = segment.pointA.x + (COLUMN_SIZE / 2) * segment.dNorm.x + (COLUMN_SIZE / 2) * segment.n.x;
                    const colAY = segment.pointA.y + (COLUMN_SIZE / 2) * segment.dNorm.y + (COLUMN_SIZE / 2) * segment.n.y;
                    ctx.fillRect(
                        mmToPx(colAX) - columnSize / 2,
                        mmToPx(colAY) - columnSize / 2,
                        columnSize,
                        columnSize
                    );
                    
                    // Column at B (on internal face - blue line)
                    // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
                    const colBX = segment.pointB.x - (COLUMN_SIZE / 2) * segment.dNorm.x + (COLUMN_SIZE / 2) * segment.n.x;
                    const colBY = segment.pointB.y - (COLUMN_SIZE / 2) * segment.dNorm.y + (COLUMN_SIZE / 2) * segment.n.y;
                    ctx.fillRect(
                        mmToPx(colBX) - columnSize / 2,
                        mmToPx(colBY) - columnSize / 2,
                        columnSize,
                        columnSize
                    );

                }

                // Draw start and end points
                ctx.fillStyle = isRestricted ? '#f44336' : '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(mmToPx(tempPoint.x), mmToPx(tempPoint.y), 6, 0, Math.PI * 2);
                ctx.fill();

                // Show info text
                const midX = (drawingWall.x + tempPoint.x) / 2;
                const midY = (drawingWall.y + tempPoint.y) / 2;
                
                ctx.fillStyle = isRestricted ? '#f44336' : '#4CAF50';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                
                if (isRestricted) {
                    ctx.fillText(
                        '✗ Cannot place here',
                        mmToPx(midX),
                        mmToPx(midY) - 10
                    );
                    ctx.font = '12px sans-serif';
                    ctx.fillText(
                        `Min distance: ${restriction.zone.distance / 10}cm`,
                        mmToPx(midX),
                        mmToPx(midY) + 10
                    );
                } else {
                    const totalLength = Math.round(tempWall.length / 10);
                    if (wallSegments.length > 1) {
                        ctx.fillText(
                            `${totalLength}cm (${wallSegments.length} walls)`,
                            mmToPx(midX),
                            mmToPx(midY) - 10
                        );
                    } else {
                        ctx.fillText(
                            `${totalLength}cm`,
                            mmToPx(midX),
                            mmToPx(midY) - 10
                        );
                    }
                }
            }

            // Show starting point when first click is placed but no preview yet
            if (drawingWall && (!tempPoint || (drawingWall.x === tempPoint.x && drawingWall.y === tempPoint.y))) {
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw pulsing ring
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 12, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Show snap indicator when hovering and ready to start drawing
            if (currentMousePos && currentMode === 'draw' && !drawingWall) {
                drawSnapIndicator(currentMousePos.x, currentMousePos.y);
            }
        }

        // Validation functions
        function validateWall(wall, wallIndex) {
            const violations = [];

            // Check length
            if (wall.length < MIN_WALL_LENGTH) {
                violations.push({
                    type: 'error',
                    message: `Wall is too short (${Math.round(wall.length / 10)}cm). Minimum: ${MIN_WALL_LENGTH / 10}cm`
                });
            }

            // Check against other walls
            walls.forEach((otherWall, otherIndex) => {
                if (wallIndex === otherIndex) return;
                
                // Skip validation between segments of the same wall (auto-split)
                if (wall.groupId && wall.groupId === otherWall.groupId) return;
                
                // Determine if walls are on same level or adjacent levels
                const onSameFloor = wall.floorId === otherWall.floorId;
                const onAdjacentFloors = Math.abs(wall.floorId - otherWall.floorId) === 1;

                // SAME LEVEL RULES (Rule 1 & 3)
                if (onSameFloor) {
                    // Check if walls are parallel
                    if (wall.isParallelTo(otherWall)) {
                        const dist = wall.distanceToWall(otherWall);
                        
                        if (dist < 10) { // Aligned (on same line)
                            // Rule 1: Aligned walls cannot overlap and must share orientation and thickness
                            if (wall.overlapsInProjection(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls overlap with Wall ${otherIndex + 1}`
                                });
                            }

                            if (!wall.sameOrientation(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share orientation with Wall ${otherIndex + 1}`
                                });
                            }

                            if (wall.thickness !== otherWall.thickness) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share thickness with Wall ${otherIndex + 1}`
                                });
                            }
                        } else {
                            // Rule 3a: Parallel walls minimum distance
                            // Check if internal faces are facing toward each other (opposite orientation)
                            let minDist;
                            if (wall.oppositeOrientation(otherWall)) {
                                // Opposite orientation: need to check if facing toward/away
                                // Facing toward = internal faces point toward each other = 1200mm
                                // Facing away = internal faces point away from each other = 600mm
                                
                                // Get midpoint of each wall
                                const wall1Mid = {
                                    x: (wall.pointA.x + wall.pointB.x) / 2,
                                    y: (wall.pointA.y + wall.pointB.y) / 2
                                };
                                const wall2Mid = {
                                    x: (otherWall.pointA.x + otherWall.pointB.x) / 2,
                                    y: (otherWall.pointA.y + otherWall.pointB.y) / 2
                                };
                                
                                // Vector from wall1 to wall2
                                const toOther = {
                                    x: wall2Mid.x - wall1Mid.x,
                                    y: wall2Mid.y - wall1Mid.y
                                };
                                
                                // Dot product of wall1's normal with direction to wall2
                                const dot1 = wall.n.x * toOther.x + wall.n.y * toOther.y;
                                
                                if (dot1 > 0) {
                                    // wall1's internal face points toward wall2 = facing toward each other
                                    minDist = MIN_DISTANCE_OPPOSITE; // 1200mm
                                } else {
                                    // wall1's internal face points away from wall2 = facing away
                                    minDist = MIN_DISTANCE_PARALLEL; // 600mm
                                }
                            } else {
                                // Same orientation: 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            }

                            // Add 2mm tolerance to avoid floating-point precision issues
                            console.log(`VALIDATE: Wall ${wallIndex} to Wall ${otherIndex}: dist=${dist.toFixed(1)}mm, minDist=${minDist}mm, threshold=${minDist-2}mm`);
                            if (dist < minDist - 2) {
                                console.log(`  -> VIOLATION: ${dist.toFixed(1)} < ${minDist - 2}`);
                                violations.push({
                                    type: 'error',
                                    message: `Too close to Wall ${otherIndex + 1} (${Math.round(dist / 10)}cm). Minimum: ${minDist / 10}cm`
                                });
                            } else {
                                console.log(`  -> OK: ${dist.toFixed(1)} >= ${minDist - 2}`);
                            }
                        }
                    }
                    // Rule 3b: Perpendicular walls have no minimum distance requirement
                }
                
                // DIFFERENT LEVEL RULES (Rule 2 & Rule 3 across levels)
                else if (onAdjacentFloors) {
                    // Check if walls are parallel
                    if (wall.isParallelTo(otherWall)) {
                        const dist = wall.distanceToWall(otherWall);
                        
                        // If overlapping (aligned on same line)
                        if (dist < 10) {
                            if (wall.overlapsInProjection(otherWall)) {
                                // Rule 2: Overlapping segments must share orientation and thickness
                                if (!wall.sameOrientation(otherWall)) {
                                    violations.push({
                                        type: 'error',
                                        message: `Overlapping wall on different floor (Wall ${otherIndex + 1}) must share orientation`
                                    });
                                }

                                if (wall.thickness !== otherWall.thickness) {
                                    violations.push({
                                        type: 'error',
                                        message: `Overlapping wall on different floor (Wall ${otherIndex + 1}) must share thickness`
                                    });
                                }
                            }
                        } else {
                            // Rule 3: Distance restrictions apply across consecutive floors too
                            let minDist;
                            if (wall.oppositeOrientation(otherWall)) {
                                // Opposite orientation: check if facing toward/away
                                const wall1Mid = {
                                    x: (wall.pointA.x + wall.pointB.x) / 2,
                                    y: (wall.pointA.y + wall.pointB.y) / 2
                                };
                                const wall2Mid = {
                                    x: (otherWall.pointA.x + otherWall.pointB.x) / 2,
                                    y: (otherWall.pointA.y + otherWall.pointB.y) / 2
                                };
                                
                                const toOther = {
                                    x: wall2Mid.x - wall1Mid.x,
                                    y: wall2Mid.y - wall1Mid.y
                                };
                                
                                const dot1 = wall.n.x * toOther.x + wall.n.y * toOther.y;
                                
                                if (dot1 > 0) {
                                    minDist = MIN_DISTANCE_OPPOSITE; // 1200mm
                                } else {
                                    minDist = MIN_DISTANCE_PARALLEL; // 600mm
                                }
                            } else {
                                // Same orientation: 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            }

                            // Add 2mm tolerance
                            console.log(`VALIDATE (cross-level): Wall ${wallIndex} to Wall ${otherIndex}: dist=${dist.toFixed(1)}mm, minDist=${minDist}mm, threshold=${minDist-2}mm`);
                            if (dist < minDist - 2) {
                                console.log(`  -> VIOLATION: ${dist.toFixed(1)} < ${minDist - 2}`);
                                violations.push({
                                    type: 'error',
                                    message: `Too close to Wall ${otherIndex + 1} on adjacent floor (${Math.round(dist / 10)}cm). Minimum: ${minDist / 10}cm`
                                });
                            } else {
                                console.log(`  -> OK: ${dist.toFixed(1)} >= ${minDist - 2}`);
                            }
                        }
                    }
                }
            });

            return violations;
        }

        function validateAllWalls() {
            const allViolations = [];
            
            walls.forEach((wall, idx) => {
                const violations = validateWall(wall, idx);
                if (violations.length > 0) {
                    allViolations.push({
                        wallIndex: idx,
                        violations: violations
                    });
                }
            });

            displayViolations(allViolations);
            draw();
        }

        function displayViolations(allViolations) {
            const violationsList = document.getElementById('violationsList');
            
            if (allViolations.length === 0) {
                violationsList.innerHTML = '<div class="no-violations">✓ All rules satisfied!</div>';
                return;
            }

            let html = '';
            allViolations.forEach(({ wallIndex, violations }) => {
                violations.forEach(v => {
                    html += `
                        <div class="violation-item ${v.type}">
                            <div class="violation-title">Wall ${wallIndex + 1}: ${v.type.toUpperCase()}</div>
                            <div>${v.message}</div>
                        </div>
                    `;
                });
            });

            violationsList.innerHTML = html;
        }

        // Mouse handling
        let currentMousePos = null;

        function getMousePosition(e) {
            const rect = canvas.getBoundingClientRect();
            // Get mouse position in canvas pixels
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            
            // Transform from screen space to world space (inverse of pan/zoom)
            const worldX = (canvasX - panOffset.x) / zoomLevel;
            const worldY = (canvasY - panOffset.y) / zoomLevel;
            
            // Convert to mm
            let x = pxToMm(worldX);
            let y = pxToMm(worldY);

            // Always snap to 300mm external grid
            x = snapToGrid(x, GRID_SIZE_EXTERNAL);
            y = snapToGrid(y, GRID_SIZE_EXTERNAL);

            return { x, y };
        }

        function drawSnapIndicator(x, y) {
            // Draw a small circle at snap point
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.arc(mmToPx(x), mmToPx(y), 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw crosshair
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 1;
            const size = 8;
            ctx.beginPath();
            ctx.moveTo(mmToPx(x) - size, mmToPx(y));
            ctx.lineTo(mmToPx(x) + size, mmToPx(y));
            ctx.moveTo(mmToPx(x), mmToPx(y) - size);
            ctx.lineTo(mmToPx(x), mmToPx(y) + size);
            ctx.stroke();
        }

        function setupEventListeners() {
        // Pan and Zoom event listeners
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Zoom in/out (reduced sensitivity)
            const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
            const newZoom = Math.max(0.5, Math.min(2, zoomLevel * zoomFactor));
            
            // Zoom toward mouse position
            const worldXBefore = (mouseX - panOffset.x) / zoomLevel;
            const worldYBefore = (mouseY - panOffset.y) / zoomLevel;
            
            zoomLevel = newZoom;
            
            panOffset.x = mouseX - worldXBefore * zoomLevel;
            panOffset.y = mouseY - worldYBefore * zoomLevel;
            
            draw();
        }, { passive: false });
        
        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = currentMode === 'draw' ? 'crosshair' : 'pointer';
            }
            
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'pointer';
                dragStartPos = null;
                originalWallPos = null;
                validateAllWalls();
                draw();
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - lastPanPos.x;
                const dy = e.clientY - lastPanPos.y;
                panOffset.x += dx;
                panOffset.y += dy;
                lastPanPos = { x: e.clientX, y: e.clientY };
                draw();
                return;
            }
            
            const pos = getMousePosition(e);
            currentMousePos = pos;

            if (currentMode === 'select' && isDragging && selectedWall) {
                // Calculate offset from drag start
                const offsetX = pos.x - dragStartPos.x;
                const offsetY = pos.y - dragStartPos.y;
                
                // Snap offset to grid
                const snappedOffsetX = snapToGrid(offsetX, GRID_SIZE_EXTERNAL);
                const snappedOffsetY = snapToGrid(offsetY, GRID_SIZE_EXTERNAL);
                
                // Update wall position
                selectedWall.pointA.x = originalWallPos.ax + snappedOffsetX;
                selectedWall.pointA.y = originalWallPos.ay + snappedOffsetY;
                selectedWall.pointB.x = originalWallPos.bx + snappedOffsetX;
                selectedWall.pointB.y = originalWallPos.by + snappedOffsetY;
                selectedWall.updateVectors();
                
                draw();
                return;
            }

            if (currentMode === 'draw' && drawingWall) {
                // Constrain to horizontal or vertical only
                const dx = Math.abs(pos.x - drawingWall.x);
                const dy = Math.abs(pos.y - drawingWall.y);
                
                if (dx > dy) {
                    // Horizontal wall
                    tempPoint = { x: pos.x, y: drawingWall.y };
                } else {
                    // Vertical wall
                    tempPoint = { x: drawingWall.x, y: pos.y };
                }
            }
            draw();
        });

        canvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = currentMode === 'draw' ? 'crosshair' : 'pointer';
            }
            
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'pointer';
                dragStartPos = null;
                originalWallPos = null;
            }
            
            currentMousePos = null;
            draw();
        });

        canvas.addEventListener('mousedown', (e) => {
            // Check for panning first
            if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
                // Middle mouse or Ctrl+Left mouse for panning
                isPanning = true;
                lastPanPos = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
                return;
            }
            
            const pos = getMousePosition(e);

            if (currentMode === 'draw') {
                if (!drawingWall) {
                    // Start drawing
                    drawingWall = pos;
                    tempPoint = pos;
                } else {
                    // Finish drawing
                    const thickness = parseInt(document.getElementById('wallThickness').value);
                    const height = 2700; // Default height
                    
                    // Constrain to horizontal or vertical
                    const dx = Math.abs(pos.x - drawingWall.x);
                    const dy = Math.abs(pos.y - drawingWall.y);
                    let finalPos = pos;
                    if (dx > dy) {
                        finalPos = { x: pos.x, y: drawingWall.y };
                    } else {
                        finalPos = { x: drawingWall.x, y: pos.y };
                    }
                    
                    // Apply flip by swapping start/end if flipped
                    const startX = wallFlipped ? finalPos.x : drawingWall.x;
                    const startY = wallFlipped ? finalPos.y : drawingWall.y;
                    const endX = wallFlipped ? drawingWall.x : finalPos.x;
                    const endY = wallFlipped ? drawingWall.y : finalPos.y;
                    
                    const newWall = new Wall(
                        startX,
                        startY,
                        endX,
                        endY,
                        thickness,
                        height,
                        null, // No groupId for single walls
                        currentFloorId // Assign to current floor
                    );

                    if (newWall.length < MIN_WALL_LENGTH) {
                        showToast(`Wall is too short. Minimum length is ${MIN_WALL_LENGTH / 10}cm`, 'error');
                        drawingWall = null;
                        tempPoint = null;
                        draw();
                        return;
                    }

                    // Check if wall is in restricted zone
                    const restriction = isWallInRestrictedZone(newWall);
                    if (restriction.restricted) {
                        let message = 'Cannot place wall here.';
                        if (restriction.zone.reason) {
                            message += ` ${restriction.zone.reason}`;
                        } else if (restriction.zone.distance) {
                            message += ` Too close to existing wall. Minimum distance required: ${restriction.zone.distance / 10}cm`;
                        }
                        showToast(message, 'error');
                        drawingWall = null;
                        tempPoint = null;
                        draw();
                        return;
                    }

                    // Add wall to walls array
                    walls.push(newWall);
                    
                    // Add to history for undo
                    addToHistory([newWall]);
                    
                    drawingWall = null;
                    tempPoint = null;
                    wallFlipped = false; // Reset flip state
                    updateUI();
                    validateAllWalls();
                }
            } else if (currentMode === 'select') {
                // Find wall at click position (only on current floor)
                selectedWall = null;
                for (let i = walls.length - 1; i >= 0; i--) {
                    if (walls[i].floorId === currentFloorId && walls[i].containsPoint(pos.x, pos.y)) {
                        selectedWall = walls[i];
                        break;
                    }
                }
                
                // If a wall is selected, start dragging
                if (selectedWall) {
                    isDragging = true;
                    dragStartPos = pos;
                    originalWallPos = {
                        ax: selectedWall.pointA.x,
                        ay: selectedWall.pointA.y,
                        bx: selectedWall.pointB.x,
                        by: selectedWall.pointB.y
                    };
                    canvas.style.cursor = 'grabbing';
                }
                
                updateUI();
                draw();
            }
        });

        // UI Event handlers
        document.getElementById('drawWallBtn').addEventListener('click', () => {
            currentMode = 'draw';
            drawingWall = null;
            tempPoint = null;
            wallFlipped = false;
            updateModeUI();
        });

        document.getElementById('selectBtn').addEventListener('click', () => {
            currentMode = 'select';
            drawingWall = null;
            tempPoint = null;
            wallFlipped = false;
            updateModeUI();
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedWall) {
                const index = walls.indexOf(selectedWall);
                if (index > -1) {
                    walls.splice(index, 1);
                    selectedWall = null;
                    updateUI();
                    validateAllWalls();
                }
            }
        });
        
        document.getElementById('flipWallBtn').addEventListener('click', () => {
            if (drawingWall && tempPoint) {
                wallFlipped = !wallFlipped;
                draw();
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Space key to flip wall during drawing
            if (e.code === 'Space' && drawingWall && tempPoint) {
                e.preventDefault(); // Prevent page scroll
                wallFlipped = !wallFlipped;
                draw();
            }
            
            // Escape key to cancel wall drawing
            if (e.key === 'Escape' && drawingWall) {
                e.preventDefault();
                drawingWall = null;
                tempPoint = null;
                wallFlipped = false;
                draw();
            }
            
            // Ctrl+Z or Cmd+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault(); // Prevent browser undo
                undo();
            }
            
            // Ctrl+Shift+Z or Cmd+Shift+Z or Ctrl+Y for redo
            if ((e.ctrlKey || e.metaKey) && (e.shiftKey && e.key === 'z' || e.key === 'y')) {
                e.preventDefault(); // Prevent browser redo
                redo();
            }
            
            // Delete or Backspace to delete selected wall
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedWall && currentMode === 'select') {
                e.preventDefault(); // Prevent browser back navigation on Backspace
                const wallIndex = walls.indexOf(selectedWall);
                if (wallIndex !== -1) {
                    walls.splice(wallIndex, 1);
                    selectedWall = null;
                    updateUI();
                    validateAllWalls();
                    showToast('Wall deleted', 'info', 2000);
                }
            }
        });

        document.getElementById('clearAllBtn').addEventListener('click', () => {
            if (walls.length > 0 && confirm('Are you sure you want to clear all walls?')) {
                walls = [];
                selectedWall = null;
                drawingWall = null;
                tempPoint = null;
                history = []; // Clear undo history
                redoHistory = []; // Clear redo history
                updateUI();
                draw();
            }
        });
        
        // Rules Modal
        const rulesModal = document.getElementById('rulesModal');
        const showRulesBtn = document.getElementById('showRulesBtn');
        const modalClose = document.querySelector('.modal-close');
        
        showRulesBtn.addEventListener('click', () => {
            rulesModal.classList.add('show');
        });
        
        modalClose.addEventListener('click', () => {
            rulesModal.classList.remove('show');
        });
        
        // Close modal when clicking outside
        window.addEventListener('click', (e) => {
            if (e.target === rulesModal) {
                rulesModal.classList.remove('show');
            }
        });

        document.getElementById('showOtherFloors').addEventListener('change', draw);
        document.getElementById('showLevelsAbove').addEventListener('change', draw);

        document.getElementById('wallThickness').addEventListener('change', () => {
            if (selectedWall) {
                selectedWall.thickness = parseInt(document.getElementById('wallThickness').value);
                selectedWall.updateVectors();
                draw();
                validateAllWalls();
            }
        });
        
        // Level management event listeners
        document.getElementById('addFloorBtn').addEventListener('click', () => {
            const newFloorId = floors.length;
            const newFloor = {
                id: newFloorId,
                name: `Level ${newFloorId + 1}`,
                height: newFloorId * 2700
            };
            floors.push(newFloor);
            updateFloorDropdown();
            currentFloorId = newFloorId;
            document.getElementById('currentFloor').value = currentFloorId;
            draw();
        });
        
        document.getElementById('removeFloorBtn').addEventListener('click', () => {
            if (floors.length > 1) {
                const confirmed = confirm(`Remove ${floors[floors.length - 1].name}? All walls on this level will be deleted.`);
                if (confirmed) {
                    const removedFloorId = floors[floors.length - 1].id;
                    floors.pop();
                    walls = walls.filter(w => w.floorId !== removedFloorId);
                    if (currentFloorId === removedFloorId) {
                        currentFloorId = floors[floors.length - 1].id;
                    }
                    updateFloorDropdown();
                    document.getElementById('currentFloor').value = currentFloorId;
                    draw();
                    validateAllWalls();
                }
            }
        });
        
        document.getElementById('currentFloor').addEventListener('change', (e) => {
            currentFloorId = parseInt(e.target.value);
            selectedWall = null;
            draw();
            validateAllWalls();
        });
        
        document.getElementById('showOtherFloors').addEventListener('change', draw);
        
        // Initialize UI
        updateFloorDropdown();
        updateModeUI();
        updateUI();
        
        // Show initial message
        document.getElementById('violationsList').innerHTML = 
            '<div class="no-violations">Draw walls to start. Click once for start point, move horizontally or vertically, then click for end point.</div>';
        }

        function updateFloorDropdown() {
            const select = document.getElementById('currentFloor');
            select.innerHTML = '';
            floors.forEach(floor => {
                const option = document.createElement('option');
                option.value = floor.id;
                option.textContent = floor.name;
                select.appendChild(option);
            });
            select.value = currentFloorId;
        }

        function updateModeUI() {
            document.querySelectorAll('.tool-buttons .btn-primary').forEach(btn => {
                btn.classList.remove('active');
            });

            if (currentMode === 'draw') {
                document.getElementById('drawWallBtn').classList.add('active');
                canvas.style.cursor = 'crosshair';
            } else if (currentMode === 'select') {
                document.getElementById('selectBtn').classList.add('active');
                canvas.style.cursor = 'pointer';
            }
        }

        function updateUI() {
            if (selectedWall) {
                document.getElementById('wallThickness').value = selectedWall.thickness;
            }

            draw();
        }
    </script>

    <!-- Rules Modal -->
    <!-- Toast Container -->
    <div id="toast-container"></div>

    <div id="rulesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📋 Positional Rules</h2>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <p class="modal-intro">The following rules from the original specification are currently implemented in this simulator:</p>
                
                <div class="rule-section">
                    <h3>1. Wall Dimensions</h3>
                    <ul>
                        <li><strong>Minimum Length:</strong> 40 cm from the 2 faces of the wall</li>
                        <li><strong>Thickness Options:</strong> 20 cm or 30 cm</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>2. Grid Alignment</h3>
                    <ul>
                        <li><strong>Grid Strategy:</strong> 30 cm external grid + 10 cm internal subdivisions</li>
                        <li><strong>Internal Face (Blue Line):</strong> Must be aligned to the 30 cm grid lines</li>
                        <li><strong>Column Positions:</strong> Columns snap to the 10 cm internal grid at both ends of each wall segment</li>
                        <li><strong>Orientation:</strong> Walls can only be drawn horizontally or vertically</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>3. Same Level Plane Rules</h3>
                    <ul>
                        <li><strong>Overlapping Walls:</strong> Each segment is separate and cannot overlap</li>
                        <li><strong>Aligned Walls:</strong> Walls on the same grid line must share orientation (same direction) and thickness</li>
                        <li><strong>No Overlap:</strong> Aligned walls cannot overlap in their projection along the wall direction</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>4. Different Level Plane Rules</h3>
                    <ul>
                        <li><strong>Vertical Stacking:</strong> Walls on different levels can overlap</li>
                        <li><strong>Matching Required:</strong> Overlapping segments across levels must share orientation and thickness</li>
                        <li><strong>Trace View:</strong> Lower levels are shown with decreasing opacity for reference</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>5. Minimum Distances (Same and Adjacent Levels)</h3>
                    <ul>
                        <li><strong>Parallel Walls (Same Orientation):</strong> Minimum 60 cm distance (measured from blue line to blue line)</li>
                        <li><strong>Parallel Walls (Opposite Orientation, Facing Toward):</strong> Minimum 120 cm distance (measured from blue line to blue line)</li>
                        <li><strong>Parallel Walls (Opposite Orientation, Facing Away):</strong> Minimum 60 cm distance</li>
                        <li><strong>Perpendicular Walls:</strong> No distance restrictions</li>
                        <li><strong>Aligned Walls:</strong> Distance rules do not apply (can be adjacent or have gaps)</li>
                        <li><strong>Cross-Level:</strong> These distance rules apply between consecutive levels (e.g., Level 1 and Level 2)</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>6. Visual Feedback</h3>
                    <ul>
                        <li><strong>Restricted Zones:</strong> Red zones appear when drawing a wall that would violate distance rules</li>
                        <li><strong>Zone Size:</strong> 60 cm or 120 cm depending on wall orientation relationship</li>
                        <li><strong>Cross-Level Zones:</strong> Restriction zones from adjacent levels are also shown</li>
                        <li><strong>Preview Colors:</strong> Green preview indicates valid placement, red preview indicates rule violation</li>
                        <li><strong>Validation:</strong> Real-time validation with detailed error messages</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

<!-- Cache buster: 1761842634 -->
