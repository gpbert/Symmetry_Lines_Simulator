<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symmetry Line Simulator - 300mm Grid Strategy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #2196F3;
            color: white;
        }

        .sidebar-header h1 {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 12px;
            opacity: 0.9;
        }

        .tools-section {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #2196F3;
            color: white;
        }

        .btn-primary:hover {
            background: #1976D2;
        }

        .btn-primary.active {
            background: #1565C0;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 6px;
            color: #555;
        }

        .property-group select,
        .property-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .property-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #555;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .toolbar {
            background: white;
            border-bottom: 1px solid #e0e0e0;
            padding: 15px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        canvas {
            cursor: crosshair;
            display: block;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 13px;
            min-width: 200px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .info-label {
            color: #666;
            margin-right: 15px;
        }

        .info-value {
            font-weight: 600;
            color: #333;
        }


        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.2s ease;
        }

        .modal.show {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: #ffffff;
            margin: 3% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 85vh;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px 30px;
            border-bottom: 2px solid #e0e0e0;
            background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }

        .modal-close {
            font-size: 32px;
            font-weight: 300;
            color: white;
            cursor: pointer;
            line-height: 1;
            transition: transform 0.2s ease;
        }

        .modal-close:hover {
            transform: scale(1.2);
        }

        .modal-body {
            padding: 30px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-intro {
            font-size: 15px;
            color: #555;
            margin-bottom: 24px;
            padding: 16px;
            background: #e3f2fd;
            border-left: 4px solid #1976d2;
            border-radius: 4px;
        }

        .rule-section {
            margin-bottom: 28px;
            padding: 20px;
            background: #fafafa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .rule-section h3 {
            margin: 0 0 16px 0;
            color: #1976d2;
            font-size: 18px;
            font-weight: 600;
            border-bottom: 2px solid #1976d2;
            padding-bottom: 8px;
        }

        .rule-section ul {
            margin: 0;
            padding-left: 24px;
            list-style-type: none;
        }

        .rule-section li {
            margin-bottom: 12px;
            line-height: 1.6;
            color: #333;
            position: relative;
        }

        .rule-section li:before {
            content: "‚ñ∏";
            position: absolute;
            left: -18px;
            color: #1976d2;
            font-weight: bold;
        }

        .rule-section li strong {
            color: #1565c0;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 13px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-label {
            color: #666;
        }

        .stat-value {
            font-weight: 600;
            color: #2196F3;
        }

        .help-text {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>Symmetry Line Simulator</h1>
        </div>

        <div class="tools-section">
            <div class="section-title">Tools</div>
            <div class="tool-buttons">
                <button id="drawWallBtn" class="btn btn-primary">
                    ‚úèÔ∏è Draw Wall
                </button>
                <button id="selectBtn" class="btn btn-secondary">
                    üëÜ Select / Move
                </button>
                <button id="deleteBtn" class="btn btn-danger">
                    üóëÔ∏è Delete Selected
                </button>
                <button id="flipWallBtn" class="btn btn-secondary">
                    üîÑ Flip Wall (Space)
                </button>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Floor Management</div>
            <div class="property-group">
                <label for="currentFloor">Current Floor</label>
                <select id="currentFloor">
                    <option value="0">Ground Floor</option>
                </select>
            </div>
            <div class="tool-buttons">
                <button id="addFloorBtn" class="btn btn-secondary">
                    ‚ûï Add Floor Above
                </button>
                <button id="removeFloorBtn" class="btn btn-secondary">
                    ‚ûñ Remove Current Floor
                </button>
            </div>
            <div class="property-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showOtherFloors" checked>
                    Show Trace
                </label>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Wall Properties</div>
            <div class="property-group">
                <label for="wallThickness">Thickness (cm)</label>
                <select id="wallThickness">
                    <option value="200">20 cm</option>
                    <option value="300">30 cm</option>
                </select>
            </div>
            <div class="property-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showGrid" checked>
                    Show Grid
                </label>
            </div>
            <div class="property-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showRestrictedZones" checked>
                    Show Restricted Zones
                </label>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Actions</div>
            <div class="tool-buttons">
                <button id="clearAllBtn" class="btn btn-secondary">
                    üîÑ Clear All
                </button>
                <button id="showRulesBtn" class="btn btn-secondary">
                    üìã Positional Rules
                </button>
            </div>
        </div>

    </div>

    <div class="main-content">
        <div class="toolbar">
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Walls:</span>
                    <span class="stat-value" id="wallCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Selected:</span>
                    <span class="stat-value" id="selectedInfo">None</span>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <script>
        // Constants
        const GRID_SIZE_EXTERNAL = 300; // mm - 300mm grid external
        const GRID_SIZE_INTERNAL = 100; // mm - 100mm internal
        const MM_TO_PX = 0.15; // Scale factor for visualization (1mm = 0.15px)
        const COLUMN_SIZE = 100; // mm - 10x10cm steel column
        const MIN_WALL_LENGTH = 400; // mm
        const MAX_WALL_LENGTH = 6000; // mm
        const MIN_DISTANCE_PARALLEL = 600; // mm
        const MIN_DISTANCE_OPPOSITE = 1200; // mm

        // State
        let walls = [];
        let selectedWall = null;
        let currentMode = 'draw';
        let drawingWall = null;
        let tempPoint = null;
        let wallFlipped = false; // Track if wall is flipped during drawing
        
        // Floor management
        let floors = [
            { id: 0, name: 'Ground Floor', height: 0 }
        ];
        let currentFloorId = 0;
        
        // Pan and Zoom state
        let panOffset = { x: 0, y: 0 };
        let zoomLevel = 1.0;
        let isPanning = false;
        let lastPanPos = { x: 0, y: 0 };

        // Canvas variables
        let canvas, ctx;
        
        // Initialize everything when DOM is ready
        window.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            
            canvas = document.getElementById('mainCanvas');
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            ctx = canvas.getContext('2d');
            console.log('Canvas and context initialized');
            
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                if (canvas.width > 0 && canvas.height > 0) {
                    draw();
                } else {
                    console.error('Canvas has zero dimensions!');
                }
            }
            
            window.addEventListener('resize', resizeCanvas);
            
            // Give the browser time to layout the DOM
            setTimeout(() => {
                resizeCanvas();
                setupEventListeners();
            }, 100);
        });

        // Wall class
        class Wall {
            constructor(ax, ay, bx, by, thickness = 200, height = 2700, groupId = null, floorId = 0) {
                // Points A and B ARE on the INTERNAL face (blue line - grid-aligned with columns)
                // The user draws on the grid lines, which become the internal face
                this.pointA = { x: ax, y: ay }; // Internal face point A (blue line, grid-aligned)
                this.pointB = { x: bx, y: by }; // Internal face point B (blue line, grid-aligned)
                this.thickness = thickness; // mm
                this.height = height; // mm
                this.groupId = groupId; // For tracking segments of the same wall
                this.floorId = floorId; // Which floor this wall belongs to
                this.updateVectors();
            }

            updateVectors() {
                // Direction vector d = AB
                this.d = {
                    x: this.pointB.x - this.pointA.x,
                    y: this.pointB.y - this.pointA.y
                };

                // Length
                this.length = Math.sqrt(this.d.x * this.d.x + this.d.y * this.d.y);

                // Normalized direction (handle zero-length case)
                if (this.length > 0) {
                    this.dNorm = {
                        x: this.d.x / this.length,
                        y: this.d.y / this.length
                    };
                } else {
                    // Default to horizontal for zero-length walls
                    this.dNorm = { x: 1, y: 0 };
                }

                // Normal vector n (perpendicular, pointing INWARD from external face)
                // Right-hand cross product: up √ó d
                this.n = {
                    x: -this.dNorm.y,
                    y: this.dNorm.x
                };
            }

            getExternalFacePoints() {
                // External face is thickness distance outward from internal face (A and B)
                return {
                    a: {
                        x: this.pointA.x + this.n.x * this.thickness,
                        y: this.pointA.y + this.n.y * this.thickness
                    },
                    b: {
                        x: this.pointB.x + this.n.x * this.thickness,
                        y: this.pointB.y + this.n.y * this.thickness
                    }
                };
            }

            getInternalFacePoints() {
                // Internal face IS points A and B (for backward compatibility)
                return {
                    a: this.pointA,
                    b: this.pointB
                };
            }

            isParallelTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot > 0.999; // Almost parallel
            }

            isPerpendicularTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot < 0.1; // Almost perpendicular
            }

            sameOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot > 0.9;
            }

            oppositeOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot < -0.9;
            }

            overlapsInProjection(other) {
                // Project both walls onto the line direction
                const dir = this.dNorm;
                
                const a1 = this.pointA.x * dir.x + this.pointA.y * dir.y;
                const b1 = this.pointB.x * dir.x + this.pointB.y * dir.y;
                const min1 = Math.min(a1, b1);
                const max1 = Math.max(a1, b1);

                const a2 = other.pointA.x * dir.x + other.pointA.y * dir.y;
                const b2 = other.pointB.x * dir.x + other.pointB.y * dir.y;
                const min2 = Math.min(a2, b2);
                const max2 = Math.max(a2, b2);

                // Allow touching at endpoints (use <= to exclude touching walls)
                // Add small tolerance for floating point comparisons
                const tolerance = 1; // 1mm tolerance
                return !(max1 <= min2 + tolerance || max2 <= min1 + tolerance);
            }

            distanceToWall(other) {
                // Calculate minimum distance between INTERNAL faces (blue lines - column face to column face)
                const internal1 = this.getInternalFacePoints();
                const internal2 = other.getInternalFacePoints();

                // Distance between the two internal faces (blue lines)
                const distances = [
                    this.pointToLineDistance(internal1.a, internal2.a, internal2.b),
                    this.pointToLineDistance(internal1.b, internal2.a, internal2.b),
                    this.pointToLineDistance(internal2.a, internal1.a, internal1.b),
                    this.pointToLineDistance(internal2.b, internal1.a, internal1.b)
                ];

                return Math.min(...distances);
            }

            pointToLineDistance(point, lineA, lineB) {
                const dx = lineB.x - lineA.x;
                const dy = lineB.y - lineA.y;
                const lenSq = dx * dx + dy * dy;
                
                if (lenSq === 0) return Math.sqrt(
                    (point.x - lineA.x) ** 2 + (point.y - lineA.y) ** 2
                );

                let t = ((point.x - lineA.x) * dx + (point.y - lineA.y) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));

                const projX = lineA.x + t * dx;
                const projY = lineA.y + t * dy;

                return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);
            }

            containsPoint(x, y, tolerance = 10) {
                const internal = this.getInternalFacePoints();
                
                // Check if point is within the wall rectangle (with tolerance)
                const dx = this.pointB.x - this.pointA.x;
                const dy = this.pointB.y - this.pointA.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = -dy / len;
                const ny = dx / len;

                // Create wall rectangle vertices
                const vertices = [
                    this.pointA,
                    this.pointB,
                    internal.b,
                    internal.a
                ];

                return this.isPointInPolygon({ x, y }, vertices, tolerance);
            }

            isPointInPolygon(point, vertices, tolerance) {
                let inside = false;
                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;
                    
                    const intersect = ((yi > point.y) !== (yj > point.y))
                        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                
                // Also check distance to edges
                for (let i = 0; i < vertices.length; i++) {
                    const j = (i + 1) % vertices.length;
                    const dist = this.pointToLineDistance(point, vertices[i], vertices[j]);
                    if (dist < tolerance) return true;
                }
                
                return inside;
            }
        }

        // Grid snapping - snap to 300mm external grid only
        function snapToGrid(value, gridSize = GRID_SIZE_EXTERNAL) {
            return Math.round(value / gridSize) * gridSize;
        }

        function mmToPx(mm) {
            return mm * MM_TO_PX;
        }

        function pxToMm(px) {
            return px / MM_TO_PX;
        }

        function pxSnapToGrid(px, gridSize = GRID_SIZE_EXTERNAL) {
            const mm = pxToMm(px);
            const snappedMm = snapToGrid(mm, gridSize);
            return mmToPx(snappedMm);
        }

        // Drawing functions
        function drawGrid() {
            if (!ctx || !canvas) {
                console.error('Canvas not initialized in drawGrid!');
                return;
            }
            
            const showGridCheckbox = document.getElementById('showGrid');
            if (showGridCheckbox && !showGridCheckbox.checked) return;
            
            const gridStepExternal = mmToPx(GRID_SIZE_EXTERNAL);
            const gridStepInternal = mmToPx(GRID_SIZE_INTERNAL);

            // Calculate visible world bounds (in pixels) accounting for pan/zoom
            const visibleLeft = -panOffset.x / zoomLevel;
            const visibleTop = -panOffset.y / zoomLevel;
            const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
            const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
            
            // Round to grid boundaries
            const startX = Math.floor(visibleLeft / gridStepExternal) * gridStepExternal;
            const endX = Math.ceil(visibleRight / gridStepExternal) * gridStepExternal;
            const startY = Math.floor(visibleTop / gridStepExternal) * gridStepExternal;
            const endY = Math.ceil(visibleBottom / gridStepExternal) * gridStepExternal;

            // Draw 300mm grid (external) - DARK, thicker lines
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2 / zoomLevel; // Adjust line width for zoom
            for (let x = startX; x <= endX; x += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(x, visibleTop);
                ctx.lineTo(x, visibleBottom);
                ctx.stroke();
            }
            for (let y = startY; y <= endY; y += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(visibleLeft, y);
                ctx.lineTo(visibleRight, y);
                ctx.stroke();
            }

            // Draw 100mm grid (internal) - lighter lines
            ctx.strokeStyle = '#dddddd';
            ctx.lineWidth = 0.5 / zoomLevel; // Adjust line width for zoom
            
            const startXInternal = Math.floor(visibleLeft / gridStepInternal) * gridStepInternal;
            const endXInternal = Math.ceil(visibleRight / gridStepInternal) * gridStepInternal;
            const startYInternal = Math.floor(visibleTop / gridStepInternal) * gridStepInternal;
            const endYInternal = Math.ceil(visibleBottom / gridStepInternal) * gridStepInternal;
            
            for (let x = startXInternal; x <= endXInternal; x += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(x % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(x, visibleTop);
                ctx.lineTo(x, visibleBottom);
                ctx.stroke();
            }
            for (let y = startYInternal; y <= endYInternal; y += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(y % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(visibleLeft, y);
                ctx.lineTo(visibleRight, y);
                ctx.stroke();
            }
        }

        function getRestrictedZones(wall) {
            // Show restricted zones from all floors on the current floor
            const zones = [];
            // Internal face is at points A and B (blue line)
            const internalY = wall.pointA.y;
            const internalX = wall.pointA.x;

            // Determine if wall is horizontal or vertical
            const isHorizontal = Math.abs(wall.d.y) < Math.abs(wall.d.x);

            // Calculate truly infinite bounds based on visible area + large margin
            const visibleLeft = -panOffset.x / zoomLevel;
            const visibleTop = -panOffset.y / zoomLevel;
            const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
            const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
            
            // Add large margin to make zones effectively infinite
            const margin = 100000; // 100 meters in pixels
            const infiniteLeft = pxToMm(visibleLeft - margin);
            const infiniteRight = pxToMm(visibleRight + margin);
            const infiniteTop = pxToMm(visibleTop - margin);
            const infiniteBottom = pxToMm(visibleBottom + margin);

            if (isHorizontal) {
                // Horizontal wall - restricted zones extend infinitely along X
                // Internal face is at A-B (y coordinate)

                // Zone away from internal face (opposite side - toward external face direction)
                const oppositeY = internalY + (wall.n.y > 0 ? MIN_DISTANCE_OPPOSITE : -MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: infiniteLeft,
                    y1: Math.min(internalY, oppositeY),
                    x2: infiniteRight,
                    y2: Math.max(internalY, oppositeY),
                    distance: MIN_DISTANCE_OPPOSITE
                });

                // Zone toward internal face (same side)
                const parallelY = internalY + (wall.n.y > 0 ? -MIN_DISTANCE_PARALLEL : MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: infiniteLeft,
                    y1: Math.min(internalY, parallelY),
                    x2: infiniteRight,
                    y2: Math.max(internalY, parallelY),
                    distance: MIN_DISTANCE_PARALLEL
                });
            } else {
                // Vertical wall - restricted zones extend infinitely along Y
                // Internal face is at A-B (x coordinate)

                // Zone away from internal face (opposite side - toward external face direction)
                const oppositeX = internalX + (wall.n.x > 0 ? MIN_DISTANCE_OPPOSITE : -MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: Math.min(internalX, oppositeX),
                    y1: infiniteTop,
                    x2: Math.max(internalX, oppositeX),
                    y2: infiniteBottom,
                    distance: MIN_DISTANCE_OPPOSITE
                });

                // Zone toward internal face (same side)
                const parallelX = internalX + (wall.n.x > 0 ? -MIN_DISTANCE_PARALLEL : MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: Math.min(internalX, parallelX),
                    y1: infiniteTop,
                    x2: Math.max(internalX, parallelX),
                    y2: infiniteBottom,
                    distance: MIN_DISTANCE_PARALLEL
                });
            }

            return zones;
        }

        function drawRestrictedZones() {
            if (!document.getElementById('showRestrictedZones').checked) return;
            
            walls.forEach(wall => {
                const zones = getRestrictedZones(wall);
                
                zones.forEach(zone => {
                    ctx.fillStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.1)' :  // Red for opposite (1200mm)
                        'rgba(255, 152, 0, 0.08)';   // Orange for parallel (600mm)
                    
                    ctx.fillRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );

                    // Draw border
                    ctx.strokeStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.3)' : 
                        'rgba(255, 152, 0, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.strokeRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );
                    ctx.setLineDash([]);
                });
            });
        }

        function isWallInRestrictedZone(newWall) {
            for (let existingWall of walls) {
                const onSameFloor = newWall.floorId === existingWall.floorId;
                const onDifferentFloor = newWall.floorId !== existingWall.floorId;
                
                // Check if walls are perpendicular - no restriction
                if (existingWall.isPerpendicularTo(newWall)) {
                    continue;
                }

                // Check if parallel
                if (existingWall.isParallelTo(newWall)) {
                    const dist = newWall.distanceToWall(existingWall);
                    
                    // Aligned walls (on same line)
                    if (dist < 10) {
                        // Check for overlap
                        const hasOverlap = newWall.overlapsInProjection(existingWall);
                        
                        if (hasOverlap && onDifferentFloor) {
                            // Rule 2: Cross-floor overlapping walls must share orientation and thickness
                            const sameOrientation = newWall.sameOrientation(existingWall);
                            const sameThickness = Math.abs(newWall.thickness - existingWall.thickness) < 1;
                            
                            if (!sameOrientation || !sameThickness) {
                                return {
                                    restricted: true,
                                    wall: existingWall,
                                    zone: { distance: 0, reason: 'Cross-floor overlap requires matching thickness and orientation' }
                                };
                            }
                        }
                        
                        // Rule 1 (same floor): Aligned walls allowed if same orientation/thickness and no overlap
                        // Rule 2 (different floors): Overlapping allowed if same orientation/thickness
                        // If we got here, the rules are satisfied
                        continue;
                    }
                    
                    // Non-aligned parallel walls on same floor need minimum distance (Rule 3a)
                    if (onSameFloor) {
                        // Use dot product to determine minimum distance
                        const dotProduct = newWall.n.x * existingWall.n.x + newWall.n.y * existingWall.n.y;
                        
                        let minDist;
                        if (dotProduct >= 0) {
                            // Same side: 600mm
                            minDist = MIN_DISTANCE_PARALLEL;
                        } else {
                            // Flipped - check if anti-parallel
                            if (dotProduct < -0.9) {
                                // Anti-parallel (opposite facing): 1200mm
                                minDist = MIN_DISTANCE_OPPOSITE;
                            } else {
                                // Parallel but not anti-parallel: 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            }
                        }

                        if (dist < minDist) {
                            return { 
                                restricted: true, 
                                wall: existingWall, 
                                zone: { distance: minDist }
                            };
                        }
                    }
                    // Different floors: no distance restriction (Rule 2 allows overlapping)
                }
            }
            return { restricted: false };
        }

        function drawWall(wall, isSelected = false, violations = [], opacity = 1.0, overrideColor = null) {
            const hasViolation = violations.length > 0;
            const external = wall.getExternalFacePoints();
            
            // Apply opacity for adjacent floor walls
            ctx.globalAlpha = opacity;

            // Draw wall body (from internal face A-B to external face)
            if (overrideColor) {
                ctx.fillStyle = overrideColor.replace(')', ', 0.15)').replace('rgb', 'rgba');
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? 'rgba(244, 67, 54, 0.2)' : 
                               isSelected ? 'rgba(33, 150, 243, 0.3)' : 'rgba(158, 158, 158, 0.3)';
                ctx.strokeStyle = hasViolation ? '#f44336' :
                                 isSelected ? '#2196F3' : '#757575';
            }
            ctx.lineWidth = isSelected ? 3 : 2;

            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw INTERNAL face line (BLUE - grid-aligned side with columns)
            // This is at points A and B
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = '#2196F3';
            }
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.stroke();

            // Draw external face line (thinner, darker)
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = hasViolation ? '#d32f2f' :
                                 isSelected ? '#1976D2' : '#424242';
            }
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.beginPath();
            ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.stroke();

            // Draw steel columns (10x10cm squares at A and B on the BLUE LINE)
            const columnSize = mmToPx(COLUMN_SIZE);
            if (overrideColor) {
                ctx.fillStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? '#f44336' :
                               isSelected ? '#2196F3' : '#616161';
            }

            // Column at A (on internal face - blue line)
            // Position column in grid cell, aligned to internal corner
            // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
            const colAX = wall.pointA.x + (COLUMN_SIZE / 2) * wall.dNorm.x + (COLUMN_SIZE / 2) * wall.n.x;
            const colAY = wall.pointA.y + (COLUMN_SIZE / 2) * wall.dNorm.y + (COLUMN_SIZE / 2) * wall.n.y;
            ctx.fillRect(
                mmToPx(colAX) - columnSize / 2,
                mmToPx(colAY) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Column at B (on internal face - blue line)
            // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
            const colBX = wall.pointB.x - (COLUMN_SIZE / 2) * wall.dNorm.x + (COLUMN_SIZE / 2) * wall.n.x;
            const colBY = wall.pointB.y - (COLUMN_SIZE / 2) * wall.dNorm.y + (COLUMN_SIZE / 2) * wall.n.y;
            ctx.fillRect(
                mmToPx(colBX) - columnSize / 2,
                mmToPx(colBY) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Draw dimensions
            if (isSelected) {
                const midX = (wall.pointA.x + wall.pointB.x) / 2;
                const midY = (wall.pointA.y + wall.pointB.y) / 2;
                
                ctx.fillStyle = '#2196F3';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `${Math.round(wall.length / 10)}cm (${wall.thickness / 10}cm thick)`,
                    mmToPx(midX),
                    mmToPx(midY) - 15
                );
            }
            
            // Reset global alpha
            ctx.globalAlpha = 1.0;
        }

        function draw() {
            console.log('draw() called');
            
            if (!ctx || !canvas) {
                console.error('Canvas not initialized in draw!');
                return;
            }
            
            console.log('Drawing on canvas:', canvas.width, 'x', canvas.height);
            
            // Clear and fill background (before transformation)
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply pan and zoom transformation
            ctx.setTransform(zoomLevel, 0, 0, zoomLevel, panOffset.x, panOffset.y);
            
            drawGrid();

            // Draw walls from floors below (trace) if enabled
            if (document.getElementById('showOtherFloors').checked) {
                walls.forEach((wall, idx) => {
                    // Only show floors below the current floor
                    if (wall.floorId < currentFloorId) {
                        // Calculate opacity based on distance from current floor
                        // 1 floor below = 0.4 opacity, 2 floors = 0.25, 3 floors = 0.15, etc.
                        const floorsBelow = currentFloorId - wall.floorId;
                        const opacity = Math.max(0.1, 0.5 - (floorsBelow * 0.15));
                        
                        // Lighter gray color for trace
                        drawWall(wall, false, [], opacity, '#90A4AE');
                    }
                });
            }

            // Get current floor walls
            const currentFloorWalls = walls.filter(w => w.floorId === currentFloorId);

            // Draw restricted zones from all floors
            if (walls.length > 0) {
                drawRestrictedZones();
            }

            // Get violations for current floor walls
            const wallViolations = new Map();
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId || 
                    wall.floorId === currentFloorId - 1 || 
                    wall.floorId === currentFloorId + 1) {
                    wallViolations.set(idx, validateWall(wall, idx));
                }
            });

            // Draw current floor walls
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId) {
                    const isSelected = wall === selectedWall;
                    const violations = wallViolations.get(idx) || [];
                    drawWall(wall, isSelected, violations);
                }
            });

            // Draw temporary wall while drawing
            if (drawingWall && tempPoint && (drawingWall.x !== tempPoint.x || drawingWall.y !== tempPoint.y)) {
                // Apply flip by swapping start/end if flipped
                const startX = wallFlipped ? tempPoint.x : drawingWall.x;
                const startY = wallFlipped ? tempPoint.y : drawingWall.y;
                const endX = wallFlipped ? drawingWall.x : tempPoint.x;
                const endY = wallFlipped ? drawingWall.y : tempPoint.y;
                
                const tempWall = new Wall(
                    startX,
                    startY,
                    endX,
                    endY,
                    parseInt(document.getElementById('wallThickness').value),
                    2700, // Default height
                    null, // No groupId for preview
                    currentFloorId // Preview on current floor
                );
                
                // Calculate wall segments if longer than MAX_WALL_LENGTH
                const wallSegments = [];
                if (tempWall.length > MAX_WALL_LENGTH) {
                    const numSegments = Math.ceil(tempWall.length / MAX_WALL_LENGTH);
                    const groupId = Date.now() + Math.random(); // Unique ID for preview segments
                    
                    for (let i = 0; i < numSegments; i++) {
                        const startRatio = i / numSegments;
                        const endRatio = (i + 1) / numSegments;
                        
                        let segStart = {
                            x: tempWall.pointA.x + tempWall.d.x * startRatio,
                            y: tempWall.pointA.y + tempWall.d.y * startRatio
                        };
                        let segEnd = {
                            x: tempWall.pointA.x + tempWall.d.x * endRatio,
                            y: tempWall.pointA.y + tempWall.d.y * endRatio
                        };
                        
                        // Snap junction points to 100mm grid (columns must be on grid)
                        // First and last points are already snapped (from user drawing)
                        if (i > 0) {
                            segStart.x = snapToGrid(segStart.x, GRID_SIZE_INTERNAL);
                            segStart.y = snapToGrid(segStart.y, GRID_SIZE_INTERNAL);
                        }
                        if (i < numSegments - 1) {
                            segEnd.x = snapToGrid(segEnd.x, GRID_SIZE_INTERNAL);
                            segEnd.y = snapToGrid(segEnd.y, GRID_SIZE_INTERNAL);
                        }
                        
                        wallSegments.push(new Wall(
                            segStart.x, segStart.y,
                            segEnd.x, segEnd.y,
                            tempWall.thickness,
                            tempWall.height,
                            groupId, // Assign the same groupId to all preview segments
                            currentFloorId // Preview on current floor
                        ));
                    }
                } else {
                    wallSegments.push(tempWall);
                }
                
                // Check if any segment is in restricted zone
                let isRestricted = false;
                let restriction = { restricted: false };
                for (let segment of wallSegments) {
                    const segRestriction = isWallInRestrictedZone(segment);
                    if (segRestriction.restricted) {
                        isRestricted = true;
                        restriction = segRestriction;
                        break;
                    }
                }
                
                // Draw each segment
                wallSegments.forEach((segment, idx) => {
                    const external = segment.getExternalFacePoints();
                
                    // Draw full wall preview (semi-transparent)
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.2)' : 'rgba(76, 175, 80, 0.2)';
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Draw INTERNAL face (BLUE - grid-aligned side with columns)
                    // This is at points A and B (the grid line)
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.stroke();

                    // Draw external face (dashed)
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw steel column previews at A and B (on the BLUE LINE)
                    const columnSize = mmToPx(COLUMN_SIZE);
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.5)' : 'rgba(76, 175, 80, 0.5)';
                    
                    // Column at A (on internal face - blue line)
                    // Position column in grid cell, aligned to internal corner
                    // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
                    const colAX = segment.pointA.x + (COLUMN_SIZE / 2) * segment.dNorm.x + (COLUMN_SIZE / 2) * segment.n.x;
                    const colAY = segment.pointA.y + (COLUMN_SIZE / 2) * segment.dNorm.y + (COLUMN_SIZE / 2) * segment.n.y;
                    ctx.fillRect(
                        mmToPx(colAX) - columnSize / 2,
                        mmToPx(colAY) - columnSize / 2,
                        columnSize,
                        columnSize
                    );
                    
                    // Column at B (on internal face - blue line)
                    // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
                    const colBX = segment.pointB.x - (COLUMN_SIZE / 2) * segment.dNorm.x + (COLUMN_SIZE / 2) * segment.n.x;
                    const colBY = segment.pointB.y - (COLUMN_SIZE / 2) * segment.dNorm.y + (COLUMN_SIZE / 2) * segment.n.y;
                    ctx.fillRect(
                        mmToPx(colBX) - columnSize / 2,
                        mmToPx(colBY) - columnSize / 2,
                        columnSize,
                        columnSize
                    );

                    // Draw segment split markers if multiple segments
                    if (wallSegments.length > 1 && idx < wallSegments.length - 1) {
                        ctx.strokeStyle = '#FF9800';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([]);
                        const splitX = segment.pointB.x;
                        const splitY = segment.pointB.y;
                        
                        // Draw a small perpendicular line at the split
                        const perpLen = 20;
                        const perpX = -segment.dNorm.y * perpLen;
                        const perpY = segment.dNorm.x * perpLen;
                        
                        ctx.beginPath();
                        ctx.moveTo(mmToPx(splitX - perpX), mmToPx(splitY - perpY));
                        ctx.lineTo(mmToPx(splitX + perpX), mmToPx(splitY + perpY));
                        ctx.stroke();
                    }
                });

                // Draw start and end points
                ctx.fillStyle = isRestricted ? '#f44336' : '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(mmToPx(tempPoint.x), mmToPx(tempPoint.y), 6, 0, Math.PI * 2);
                ctx.fill();

                // Show info text
                const midX = (drawingWall.x + tempPoint.x) / 2;
                const midY = (drawingWall.y + tempPoint.y) / 2;
                
                ctx.fillStyle = isRestricted ? '#f44336' : '#4CAF50';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                
                if (isRestricted) {
                    ctx.fillText(
                        '‚úó Cannot place here',
                        mmToPx(midX),
                        mmToPx(midY) - 10
                    );
                    ctx.font = '12px sans-serif';
                    ctx.fillText(
                        `Min distance: ${restriction.zone.distance / 10}cm`,
                        mmToPx(midX),
                        mmToPx(midY) + 10
                    );
                } else {
                    const totalLength = Math.round(tempWall.length / 10);
                    if (wallSegments.length > 1) {
                        ctx.fillText(
                            `${totalLength}cm (${wallSegments.length} walls)`,
                            mmToPx(midX),
                            mmToPx(midY) - 10
                        );
                    } else {
                        ctx.fillText(
                            `${totalLength}cm`,
                            mmToPx(midX),
                            mmToPx(midY) - 10
                        );
                    }
                }
            }

            // Show starting point when first click is placed but no preview yet
            if (drawingWall && (!tempPoint || (drawingWall.x === tempPoint.x && drawingWall.y === tempPoint.y))) {
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw pulsing ring
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 12, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Show snap indicator when hovering and ready to start drawing
            if (currentMousePos && currentMode === 'draw' && !drawingWall) {
                drawSnapIndicator(currentMousePos.x, currentMousePos.y);
            }
        }

        // Validation functions
        function validateWall(wall, wallIndex) {
            const violations = [];

            // Check length
            if (wall.length < MIN_WALL_LENGTH) {
                violations.push({
                    type: 'error',
                    message: `Wall is too short (${Math.round(wall.length / 10)}cm). Minimum: ${MIN_WALL_LENGTH / 10}cm`
                });
            }

            if (wall.length > MAX_WALL_LENGTH) {
                violations.push({
                    type: 'error',
                    message: `Wall is too long (${Math.round(wall.length / 10)}cm). Maximum: ${MAX_WALL_LENGTH / 10}cm`
                });
            }

            // Check against other walls
            walls.forEach((otherWall, otherIndex) => {
                if (wallIndex === otherIndex) return;
                
                // Skip validation between segments of the same wall (auto-split)
                if (wall.groupId && wall.groupId === otherWall.groupId) return;
                
                // Determine if walls are on same floor or adjacent floors
                const onSameFloor = wall.floorId === otherWall.floorId;
                const onAdjacentFloors = Math.abs(wall.floorId - otherWall.floorId) === 1;

                // SAME FLOOR RULES (Rule 1 & 3)
                if (onSameFloor) {
                    // Check if walls are parallel
                    if (wall.isParallelTo(otherWall)) {
                        const dist = wall.distanceToWall(otherWall);
                        
                        if (dist < 10) { // Aligned (on same line)
                            // Rule 1: Aligned walls cannot overlap and must share orientation and thickness
                            if (wall.overlapsInProjection(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls overlap with Wall ${otherIndex + 1}`
                                });
                            }

                            if (!wall.sameOrientation(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share orientation with Wall ${otherIndex + 1}`
                                });
                            }

                            if (wall.thickness !== otherWall.thickness) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share thickness with Wall ${otherIndex + 1}`
                                });
                            }
                        } else {
                            // Rule 3a: Parallel walls minimum distance
                            // Use dot product to determine orientation relationship
                            const dotProduct = wall.n.x * otherWall.n.x + wall.n.y * otherWall.n.y;
                            
                            let minDist;
                            if (dotProduct >= 0) {
                                // Same side (normals point in similar directions): 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            } else {
                                // Flipped - check if anti-parallel (opposite facing)
                                if (dotProduct < -0.9) {
                                    // Anti-parallel (opposite facing): 1200mm
                                    minDist = MIN_DISTANCE_OPPOSITE;
                                } else {
                                    // Parallel but not anti-parallel: 600mm
                                    minDist = MIN_DISTANCE_PARALLEL;
                                }
                            }

                            if (dist < minDist) {
                                violations.push({
                                    type: 'error',
                                    message: `Too close to Wall ${otherIndex + 1} (${Math.round(dist / 10)}cm). Minimum: ${minDist / 10}cm`
                                });
                            }
                        }
                    }
                    // Rule 3b: Perpendicular walls have no minimum distance requirement
                }
                
                // DIFFERENT FLOOR RULES (Rule 2)
                else if (onAdjacentFloors) {
                    // Check if walls are parallel and overlapping
                    if (wall.isParallelTo(otherWall)) {
                        const dist = wall.distanceToWall(otherWall);
                        
                        // If overlapping (aligned on same line)
                        if (dist < 10 && wall.overlapsInProjection(otherWall)) {
                            // Rule 2: Overlapping segments must share orientation and thickness
                            if (!wall.sameOrientation(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Overlapping wall on different floor (Wall ${otherIndex + 1}) must share orientation`
                                });
                            }

                            if (wall.thickness !== otherWall.thickness) {
                                violations.push({
                                    type: 'error',
                                    message: `Overlapping wall on different floor (Wall ${otherIndex + 1}) must share thickness`
                                });
                            }
                        }
                    }
                    // No distance restrictions between floors for non-overlapping walls
                }
            });

            return violations;
        }

        function validateAllWalls() {
            const allViolations = [];
            
            walls.forEach((wall, idx) => {
                const violations = validateWall(wall, idx);
                if (violations.length > 0) {
                    allViolations.push({
                        wallIndex: idx,
                        violations: violations
                    });
                }
            });

            displayViolations(allViolations);
            draw();
        }

        function displayViolations(allViolations) {
            const violationsList = document.getElementById('violationsList');
            
            if (allViolations.length === 0) {
                violationsList.innerHTML = '<div class="no-violations">‚úì All rules satisfied!</div>';
                return;
            }

            let html = '';
            allViolations.forEach(({ wallIndex, violations }) => {
                violations.forEach(v => {
                    html += `
                        <div class="violation-item ${v.type}">
                            <div class="violation-title">Wall ${wallIndex + 1}: ${v.type.toUpperCase()}</div>
                            <div>${v.message}</div>
                        </div>
                    `;
                });
            });

            violationsList.innerHTML = html;
        }

        // Mouse handling
        let currentMousePos = null;

        function getMousePosition(e) {
            const rect = canvas.getBoundingClientRect();
            // Get mouse position in canvas pixels
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            
            // Transform from screen space to world space (inverse of pan/zoom)
            const worldX = (canvasX - panOffset.x) / zoomLevel;
            const worldY = (canvasY - panOffset.y) / zoomLevel;
            
            // Convert to mm
            let x = pxToMm(worldX);
            let y = pxToMm(worldY);

            // Always snap to 300mm external grid
            x = snapToGrid(x, GRID_SIZE_EXTERNAL);
            y = snapToGrid(y, GRID_SIZE_EXTERNAL);

            return { x, y };
        }

        function drawSnapIndicator(x, y) {
            // Draw a small circle at snap point
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.arc(mmToPx(x), mmToPx(y), 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw crosshair
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 1;
            const size = 8;
            ctx.beginPath();
            ctx.moveTo(mmToPx(x) - size, mmToPx(y));
            ctx.lineTo(mmToPx(x) + size, mmToPx(y));
            ctx.moveTo(mmToPx(x), mmToPx(y) - size);
            ctx.lineTo(mmToPx(x), mmToPx(y) + size);
            ctx.stroke();
        }

        function setupEventListeners() {
        // Pan and Zoom event listeners
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Zoom in/out (reduced sensitivity)
            const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
            const newZoom = Math.max(0.5, Math.min(2, zoomLevel * zoomFactor));
            
            // Zoom toward mouse position
            const worldXBefore = (mouseX - panOffset.x) / zoomLevel;
            const worldYBefore = (mouseY - panOffset.y) / zoomLevel;
            
            zoomLevel = newZoom;
            
            panOffset.x = mouseX - worldXBefore * zoomLevel;
            panOffset.y = mouseY - worldYBefore * zoomLevel;
            
            draw();
        }, { passive: false });
        
        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = currentMode === 'draw' ? 'crosshair' : 'pointer';
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - lastPanPos.x;
                const dy = e.clientY - lastPanPos.y;
                panOffset.x += dx;
                panOffset.y += dy;
                lastPanPos = { x: e.clientX, y: e.clientY };
                draw();
                return;
            }
            
            const pos = getMousePosition(e);
            currentMousePos = pos;

            if (currentMode === 'draw' && drawingWall) {
                // Constrain to horizontal or vertical only
                const dx = Math.abs(pos.x - drawingWall.x);
                const dy = Math.abs(pos.y - drawingWall.y);
                
                if (dx > dy) {
                    // Horizontal wall
                    tempPoint = { x: pos.x, y: drawingWall.y };
                } else {
                    // Vertical wall
                    tempPoint = { x: drawingWall.x, y: pos.y };
                }
            }
            draw();
        });

        canvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = currentMode === 'draw' ? 'crosshair' : 'pointer';
            }
            currentMousePos = null;
            draw();
        });

        canvas.addEventListener('mousedown', (e) => {
            // Check for panning first
            if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
                // Middle mouse or Ctrl+Left mouse for panning
                isPanning = true;
                lastPanPos = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
                return;
            }
            
            const pos = getMousePosition(e);

            if (currentMode === 'draw') {
                if (!drawingWall) {
                    // Start drawing
                    drawingWall = pos;
                    tempPoint = pos;
                } else {
                    // Finish drawing
                    const thickness = parseInt(document.getElementById('wallThickness').value);
                    const height = 2700; // Default height
                    
                    // Constrain to horizontal or vertical
                    const dx = Math.abs(pos.x - drawingWall.x);
                    const dy = Math.abs(pos.y - drawingWall.y);
                    let finalPos = pos;
                    if (dx > dy) {
                        finalPos = { x: pos.x, y: drawingWall.y };
                    } else {
                        finalPos = { x: drawingWall.x, y: pos.y };
                    }
                    
                    // Apply flip by swapping start/end if flipped
                    const startX = wallFlipped ? finalPos.x : drawingWall.x;
                    const startY = wallFlipped ? finalPos.y : drawingWall.y;
                    const endX = wallFlipped ? drawingWall.x : finalPos.x;
                    const endY = wallFlipped ? drawingWall.y : finalPos.y;
                    
                    const newWall = new Wall(
                        startX,
                        startY,
                        endX,
                        endY,
                        thickness,
                        height,
                        null, // No groupId for single walls
                        currentFloorId // Assign to current floor
                    );

                    if (newWall.length < MIN_WALL_LENGTH) {
                        alert(`Wall is too short. Minimum length is ${MIN_WALL_LENGTH / 10}cm`);
                        drawingWall = null;
                        tempPoint = null;
                        draw();
                        return;
                    }

                    // Calculate wall segments if longer than MAX_WALL_LENGTH
                    const wallSegments = [];
                    if (newWall.length > MAX_WALL_LENGTH) {
                        const numSegments = Math.ceil(newWall.length / MAX_WALL_LENGTH);
                        const groupId = Date.now() + Math.random(); // Unique ID for this wall group
                        
                        for (let i = 0; i < numSegments; i++) {
                            const startRatio = i / numSegments;
                            const endRatio = (i + 1) / numSegments;
                            
                            let segStart = {
                                x: newWall.pointA.x + newWall.d.x * startRatio,
                                y: newWall.pointA.y + newWall.d.y * startRatio
                            };
                            let segEnd = {
                                x: newWall.pointA.x + newWall.d.x * endRatio,
                                y: newWall.pointA.y + newWall.d.y * endRatio
                            };
                            
                            // Snap junction points to 100mm grid (columns must be on grid)
                            // First and last points are already snapped (from user drawing)
                            if (i > 0) {
                                segStart.x = snapToGrid(segStart.x, GRID_SIZE_INTERNAL);
                                segStart.y = snapToGrid(segStart.y, GRID_SIZE_INTERNAL);
                            }
                            if (i < numSegments - 1) {
                                segEnd.x = snapToGrid(segEnd.x, GRID_SIZE_INTERNAL);
                                segEnd.y = snapToGrid(segEnd.y, GRID_SIZE_INTERNAL);
                            }
                            
                            wallSegments.push(new Wall(
                                segStart.x, segStart.y,
                                segEnd.x, segEnd.y,
                                thickness,
                                height,
                                groupId, // Assign the same groupId to all segments
                                currentFloorId // Assign to current floor
                            ));
                        }
                    } else {
                        wallSegments.push(newWall);
                    }

                    // Check if any segment is in restricted zone
                    for (let segment of wallSegments) {
                        const restriction = isWallInRestrictedZone(segment);
                        if (restriction.restricted) {
                            let message = 'Cannot place wall here.';
                            if (restriction.zone.reason) {
                                message += `\n${restriction.zone.reason}`;
                            } else if (restriction.zone.distance) {
                                message += `\nToo close to existing wall. Minimum distance required: ${restriction.zone.distance / 10}cm`;
                            }
                            alert(message);
                            drawingWall = null;
                            tempPoint = null;
                            draw();
                            return;
                        }
                    }

                    // Add all segments to walls array
                    wallSegments.forEach(segment => {
                        walls.push(segment);
                    });
                    
                    drawingWall = null;
                    tempPoint = null;
                    wallFlipped = false; // Reset flip state
                    updateUI();
                    validateAllWalls();
                }
            } else if (currentMode === 'select') {
                // Find wall at click position (only on current floor)
                selectedWall = null;
                for (let i = walls.length - 1; i >= 0; i--) {
                    if (walls[i].floorId === currentFloorId && walls[i].containsPoint(pos.x, pos.y)) {
                        selectedWall = walls[i];
                        break;
                    }
                }
                updateUI();
                draw();
            }
        });

        // UI Event handlers
        document.getElementById('drawWallBtn').addEventListener('click', () => {
            currentMode = 'draw';
            drawingWall = null;
            tempPoint = null;
            wallFlipped = false;
            updateModeUI();
        });

        document.getElementById('selectBtn').addEventListener('click', () => {
            currentMode = 'select';
            drawingWall = null;
            tempPoint = null;
            wallFlipped = false;
            updateModeUI();
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedWall) {
                const index = walls.indexOf(selectedWall);
                if (index > -1) {
                    walls.splice(index, 1);
                    selectedWall = null;
                    updateUI();
                    validateAllWalls();
                }
            }
        });
        
        document.getElementById('flipWallBtn').addEventListener('click', () => {
            if (drawingWall && tempPoint) {
                wallFlipped = !wallFlipped;
                draw();
            }
        });
        
        // Space key to flip wall during drawing
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && drawingWall && tempPoint) {
                e.preventDefault(); // Prevent page scroll
                wallFlipped = !wallFlipped;
                draw();
            }
        });

        document.getElementById('clearAllBtn').addEventListener('click', () => {
            if (walls.length > 0 && confirm('Are you sure you want to clear all walls?')) {
                walls = [];
                selectedWall = null;
                drawingWall = null;
                tempPoint = null;
                updateUI();
                draw();
            }
        });
        
        // Rules Modal
        const rulesModal = document.getElementById('rulesModal');
        const showRulesBtn = document.getElementById('showRulesBtn');
        const modalClose = document.querySelector('.modal-close');
        
        showRulesBtn.addEventListener('click', () => {
            rulesModal.classList.add('show');
        });
        
        modalClose.addEventListener('click', () => {
            rulesModal.classList.remove('show');
        });
        
        // Close modal when clicking outside
        window.addEventListener('click', (e) => {
            if (e.target === rulesModal) {
                rulesModal.classList.remove('show');
            }
        });

        document.getElementById('showGrid').addEventListener('change', draw);
        document.getElementById('showRestrictedZones').addEventListener('change', draw);

        document.getElementById('wallThickness').addEventListener('change', () => {
            if (selectedWall) {
                selectedWall.thickness = parseInt(document.getElementById('wallThickness').value);
                selectedWall.updateVectors();
                draw();
                validateAllWalls();
            }
        });
        
        // Floor management event listeners
        document.getElementById('addFloorBtn').addEventListener('click', () => {
            const newFloorId = floors.length;
            const newFloor = {
                id: newFloorId,
                name: `Floor ${newFloorId}`,
                height: newFloorId * 2700
            };
            floors.push(newFloor);
            updateFloorDropdown();
            currentFloorId = newFloorId;
            document.getElementById('currentFloor').value = currentFloorId;
            draw();
        });
        
        document.getElementById('removeFloorBtn').addEventListener('click', () => {
            if (floors.length > 1) {
                const confirmed = confirm(`Remove ${floors[floors.length - 1].name}? All walls on this floor will be deleted.`);
                if (confirmed) {
                    const removedFloorId = floors[floors.length - 1].id;
                    floors.pop();
                    walls = walls.filter(w => w.floorId !== removedFloorId);
                    if (currentFloorId === removedFloorId) {
                        currentFloorId = floors[floors.length - 1].id;
                    }
                    updateFloorDropdown();
                    document.getElementById('currentFloor').value = currentFloorId;
                    draw();
                    validateAllWalls();
                }
            }
        });
        
        document.getElementById('currentFloor').addEventListener('change', (e) => {
            currentFloorId = parseInt(e.target.value);
            selectedWall = null;
            draw();
            validateAllWalls();
        });
        
        document.getElementById('showOtherFloors').addEventListener('change', draw);
        
        // Initialize UI
        updateFloorDropdown();
        updateModeUI();
        updateUI();
        
        // Show initial message
        document.getElementById('violationsList').innerHTML = 
            '<div class="no-violations">Draw walls to start. Click once for start point, move horizontally or vertically, then click for end point.</div>';
        }

        function updateFloorDropdown() {
            const select = document.getElementById('currentFloor');
            select.innerHTML = '';
            floors.forEach(floor => {
                const option = document.createElement('option');
                option.value = floor.id;
                option.textContent = floor.name;
                select.appendChild(option);
            });
            select.value = currentFloorId;
        }

        function updateModeUI() {
            document.querySelectorAll('.tool-buttons .btn-primary').forEach(btn => {
                btn.classList.remove('active');
            });

            if (currentMode === 'draw') {
                document.getElementById('drawWallBtn').classList.add('active');
                canvas.style.cursor = 'crosshair';
            } else if (currentMode === 'select') {
                document.getElementById('selectBtn').classList.add('active');
                canvas.style.cursor = 'pointer';
            }
        }

        function updateUI() {
            document.getElementById('wallCount').textContent = walls.length;
            document.getElementById('selectedInfo').textContent = 
                selectedWall ? `Wall ${walls.indexOf(selectedWall) + 1}` : 'None';

            if (selectedWall) {
                document.getElementById('wallThickness').value = selectedWall.thickness;
            }

            draw();
        }
    </script>

    <!-- Rules Modal -->
    <div id="rulesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìã Positional Rules</h2>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <p class="modal-intro">The following rules from the original specification are currently implemented in this simulator:</p>
                
                <div class="rule-section">
                    <h3>1. Wall Dimensions</h3>
                    <ul>
                        <li><strong>Minimum Length:</strong> 40 cm from the 2 faces of the wall</li>
                        <li><strong>Maximum Length:</strong> 600 cm (walls longer than this are automatically split into segments)</li>
                        <li><strong>Thickness Options:</strong> 20 cm or 30 cm</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>2. Grid Alignment</h3>
                    <ul>
                        <li><strong>Grid Strategy:</strong> 30 cm external grid + 10 cm internal subdivisions</li>
                        <li><strong>Internal Face (Blue Line):</strong> Must be aligned to the 30 cm grid lines</li>
                        <li><strong>Column Positions:</strong> Columns snap to the 10 cm internal grid at both ends of each wall segment</li>
                        <li><strong>Orientation:</strong> Walls can only be drawn horizontally or vertically</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>3. Same Floor Plane Rules</h3>
                    <ul>
                        <li><strong>Overlapping Walls:</strong> Each segment is separate and cannot overlap</li>
                        <li><strong>Aligned Walls:</strong> Walls on the same grid line must share orientation (same direction) and thickness</li>
                        <li><strong>No Overlap:</strong> Aligned walls cannot overlap in their projection along the wall direction</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>4. Different Floor Plane Rules</h3>
                    <ul>
                        <li><strong>Vertical Stacking:</strong> Walls on different floors can overlap</li>
                        <li><strong>Matching Required:</strong> Overlapping segments across floors must share orientation and thickness</li>
                        <li><strong>Trace View:</strong> Lower floors are shown with decreasing opacity for reference</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>5. Minimum Distances (Same Floor Only)</h3>
                    <ul>
                        <li><strong>Parallel Walls (Same Orientation):</strong> Minimum 60 cm distance (measured from blue line to blue line)</li>
                        <li><strong>Parallel Walls (Opposite Orientation):</strong> Minimum 120 cm distance (measured from blue line to blue line)</li>
                        <li><strong>Perpendicular Walls:</strong> No distance restrictions</li>
                        <li><strong>Aligned Walls:</strong> Distance rules do not apply (can be adjacent or have gaps)</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>6. Visual Feedback</h3>
                    <ul>
                        <li><strong>Restricted Zones:</strong> Orange (60 cm) and red (120 cm) zones show where new walls cannot be placed</li>
                        <li><strong>Preview Colors:</strong> Green preview indicates valid placement, red preview indicates rule violation</li>
                        <li><strong>Validation:</strong> Real-time validation with detailed error messages</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

