<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>30cm Grid Simulator</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><radialGradient id='g' cx='30%25' cy='30%25'><stop offset='0%25' stop-color='%23888888'/><stop offset='50%25' stop-color='%23333333'/><stop offset='100%25' stop-color='%23000000'/></radialGradient></defs><circle cx='50' cy='50' r='50' fill='url(%23g)'/></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
            display: flex;
            height: 100vh;
            overflow: hidden;
            color: #1a1a1a;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .sidebar {
            width: 240px;
            background: #ffffff;
            border-right: 1px solid #e8e8e8;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 2px 0 12px rgba(0, 0, 0, 0.02);
        }

        .sidebar-header {
            padding: 32px 24px;
            border-bottom: 1px solid #e8e8e8;
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
        }

        .sidebar-header h1 {
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #2a2a2a;
            margin-bottom: 6px;
            text-align: center;
        }

        .sidebar-header p {
            font-size: 12px;
            font-weight: 400;
            color: #6b6b6b;
            letter-spacing: 0;
        }

        .tools-section {
            padding: 24px;
            border-bottom: 1px solid #f0f0f0;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #8a8a8a;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .tool-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn {
            padding: 10px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            background: #ffffff;
            color: #2a2a2a;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
            letter-spacing: -0.01em;
        }
        
        .btn svg {
            flex-shrink: 0;
            opacity: 0.7;
            transition: opacity 0.15s ease;
        }

        .btn:hover {
            border-color: #d0d0d0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
            transform: translateY(-1px);
        }
        
        .btn:hover svg {
            opacity: 1;
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
        }

        .btn-primary {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            color: #ffffff;
            border-color: #1a1a1a;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%);
            border-color: #0a0a0a;
        }

        .btn-primary.active {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            box-shadow: 0 0 0 3px rgba(42, 42, 42, 0.1);
        }

        .btn-secondary {
            background: #ffffff;
            color: #4a4a4a;
            border-color: #e8e8e8;
        }

        .btn-secondary:hover {
            background: #fafafa;
            border-color: #d8d8d8;
        }

        .btn-danger {
            background: #ffffff;
            color: #d14343;
            border-color: #f0d0d0;
        }

        .btn-danger:hover {
            background: #fef5f5;
            border-color: #f0c0c0;
            color: #c13333;
        }
        
        .btn-danger.active {
            background: #d14343;
            color: #ffffff;
            border-color: #d14343;
            box-shadow: 0 0 0 3px rgba(209, 67, 67, 0.1);
        }
        
        .btn-secondary.active {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            color: #ffffff;
            box-shadow: 0 0 0 3px rgba(42, 42, 42, 0.1);
        }

        .property-group {
            margin-bottom: 18px;
        }

        .property-group label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #5a5a5a;
            letter-spacing: -0.01em;
        }

        .property-group select,
        .property-group input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            background: #ffffff;
            color: #2a2a2a;
            transition: all 0.15s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
        }

        .property-group select:hover,
        .property-group input:hover {
            border-color: #d0d0d0;
        }

        .property-group select:focus,
        .property-group input:focus {
            outline: none;
            border-color: #a0a0a0;
            box-shadow: 0 0 0 3px rgba(42, 42, 42, 0.05);
        }

        .property-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
            accent-color: #2a2a2a;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #4a4a4a;
            cursor: pointer;
            transition: color 0.15s ease;
        }

        .checkbox-label:hover {
            color: #2a2a2a;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #fefefe 0%, #fafafa 100%);
        }

        canvas {
            cursor: crosshair;
            display: block;
        }

        .info-panel {
            position: absolute;
            top: 24px;
            right: 24px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.06);
            font-size: 12px;
            min-width: 200px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .info-label {
            color: #6b6b6b;
            margin-right: 16px;
            font-weight: 400;
        }

        .info-value {
            font-weight: 500;
            color: #2a2a2a;
            letter-spacing: -0.01em;
        }


        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal.show {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 820px;
            max-height: 85vh;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
            animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        @keyframes slideDown {
            from {
                transform: translateY(-30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 28px 32px;
            border-bottom: 1px solid #f0f0f0;
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
            border-radius: 12px 12px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            letter-spacing: -0.02em;
        }

        .modal-close {
            font-size: 28px;
            font-weight: 300;
            color: #8a8a8a;
            cursor: pointer;
            line-height: 1;
            transition: all 0.15s ease;
            padding: 4px;
        }

        .modal-close:hover {
            color: #2a2a2a;
            transform: scale(1.05);
        }

        .modal-body {
            padding: 32px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-intro {
            font-size: 13px;
            color: #5a5a5a;
            line-height: 1.6;
            margin-bottom: 28px;
            padding: 16px 18px;
            background: #fafafa;
            border-left: 2px solid #d0d0d0;
            border-radius: 6px;
        }

        .rule-section {
            margin-bottom: 24px;
            padding: 20px 22px;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #e8e8e8;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
        }

        .rule-section h3 {
            margin: 0 0 16px 0;
            color: #2a2a2a;
            font-size: 15px;
            font-weight: 600;
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 10px;
            letter-spacing: -0.01em;
        }

        .rule-section ul {
            margin: 0;
            padding-left: 20px;
            list-style-type: none;
        }

        .rule-section li {
            margin-bottom: 10px;
            line-height: 1.65;
            color: #4a4a4a;
            position: relative;
            font-size: 13px;
        }

        .rule-section li:before {
            content: "•";
            position: absolute;
            left: -14px;
            color: #b0b0b0;
            font-weight: normal;
        }

        .rule-section li strong {
            color: #2a2a2a;
            font-weight: 600;
        }

        .help-text {
            font-size: 11px;
            color: #8a8a8a;
            margin-top: 6px;
            line-height: 1.5;
        }

        /* Toast Messages */
        #toast-container {
            position: fixed;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
            align-items: center;
        }

        .toast {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 14px 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            pointer-events: auto;
            animation: fadeInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toast.error {
            background: rgba(239, 68, 68, 0.95);
        }

        .toast.warning {
            background: rgba(251, 146, 60, 0.95);
        }

        .toast.info {
            background: rgba(59, 130, 246, 0.95);
        }

        .toast-content {
            flex: 1;
        }

        .toast-message {
            color: #ffffff;
            font-size: 14px;
            font-weight: 500;
            line-height: 1.4;
            margin: 0;
            text-align: center;
            letter-spacing: 0.2px;
        }

        @keyframes fadeInUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes fadeOutDown {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(20px);
                opacity: 0;
            }
        }

        .toast.hiding {
            animation: fadeOutDown 0.3s cubic-bezier(0.4, 0, 1, 1) forwards;
        }
        
        /* Pulsing animation for restricting walls */
        @keyframes wallPulse {
            0%, 100% {
                opacity: 0.3;
            }
            50% {
                opacity: 0.6;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>30cm Grid Simulator</h1>
        </div>

        <div class="tools-section">
            <div class="section-title">Tools</div>
            <div class="tool-buttons">
                <button id="drawWallBtn" class="btn btn-secondary">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M10.5 1.5L12.5 3.5L4.5 11.5L1.5 12.5L2.5 9.5L10.5 1.5Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Draw Wall
                </button>
                <button id="selectBtn" class="btn btn-secondary">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M1 1L5.5 13L7 8L13 6.5L1 1Z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
                    </svg>
                    Select
                </button>
                <button id="deleteBtn" class="btn btn-danger">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M1 3.5H13M5.5 6V10.5M8.5 6V10.5M2 3.5L3 12.5H11L12 3.5M4.5 3.5V1.5H9.5V3.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Delete
                </button>
                <button id="flipWallBtn" class="btn btn-secondary">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M11 4L13 7L11 10M3 10L1 7L3 4M8.5 2L5.5 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Flip Wall (Space)
                </button>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Level Management</div>
            <div class="property-group">
                <label for="currentFloor">Current Level</label>
                <select id="currentFloor">
                    <option value="0">Level 1</option>
                </select>
            </div>
            <div class="tool-buttons">
                <button id="addFloorBtn" class="btn btn-secondary">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M7 1V13M1 7H13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                    Add Level Above
                </button>
                <button id="removeFloorBtn" class="btn btn-secondary">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M1 7H13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                    Remove Current Level
                </button>
            </div>
            <div class="property-group" style="margin-top: 24px;">
                <label class="checkbox-label">
                    <input type="checkbox" id="showLevelsAbove" checked>
                    Show Levels Above
                </label>
            </div>
            <div class="property-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showOtherFloors" checked>
                    Show Levels Below
                </label>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Wall Properties</div>
            <div class="property-group">
                <label for="wallThickness">Thickness (cm)</label>
                <select id="wallThickness">
                    <option value="200">20 cm</option>
                    <option value="300">30 cm</option>
                </select>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Actions</div>
            <div class="tool-buttons">
                <button id="clearAllBtn" class="btn btn-secondary">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 4C9.5 1.5 4.5 1.5 2 4M2 10C4.5 12.5 9.5 12.5 12 10M3 3.5L1 5.5V1.5H5M11 10.5L13 8.5V12.5H9" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Clear All
                </button>
                <button id="showRulesBtn" class="btn btn-secondary">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2 1.5H12C12.5 1.5 13 2 13 2.5V11.5C13 12 12.5 12.5 12 12.5H2C1.5 12.5 1 12 1 11.5V2.5C1 2 1.5 1.5 2 1.5ZM4 4.5H10M4 7H10M4 9.5H8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                    Positional Rules
                </button>
                <button id="feedbackBtn" class="btn btn-secondary">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M7 13C10.3137 13 13 10.3137 13 7C13 3.68629 10.3137 1 7 1C3.68629 1 1 3.68629 1 7C1 8.5 1.5 9.8 2.5 10.8L1.5 13L4 12C5 12.6 6 13 7 13Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Send Feedback
                </button>
                
                <div id="versionBadge" style="margin-top: 16px; padding: 12px; background: rgba(0, 0, 0, 0.02); border: 1px solid rgba(0, 0, 0, 0.06); border-radius: 8px; cursor: pointer; transition: all 0.2s ease; text-align: center;">
                    <div style="font-size: 11px; color: #9b9b9b; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px;">Version</div>
                    <div style="font-size: 14px; font-weight: 500; color: #2a2a2a;">1.1.0</div>
                </div>
            </div>
        </div>

    </div>

    <div class="main-content">
        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <script>
        // Constants
        const GRID_SIZE_EXTERNAL = 300; // mm - 300mm grid external
        const GRID_SIZE_INTERNAL = 100; // mm - 100mm internal
        const MM_TO_PX = 0.15; // Scale factor for visualization (1mm = 0.15px)
        const COLUMN_SIZE = 100; // mm - 10x10cm steel column
        const MIN_WALL_LENGTH = 400; // mm
        const MIN_DISTANCE_PARALLEL = 600; // mm
        const MIN_DISTANCE_OPPOSITE = 1200; // mm

        // State
        let walls = [];
        let selectedWalls = []; // Array to support multi-select
        let currentMode = 'draw'; // 'draw', 'select', 'delete'
        let drawingWall = null;
        let tempPoint = null;
        let wallFlipped = false; // Track if wall is flipped during drawing
        let drawingToastElement = null; // Track the current drawing toast
        
        // Undo history - stores operations (each operation can contain multiple walls)
        let history = [];
        const MAX_HISTORY = 50; // Keep last 50 operations
        
        // Level management
        let floors = [
            { id: 0, name: 'Level 1', height: 0 }
        ];
        let currentFloorId = 0;
        
        // Pan and Zoom state
        let panOffset = { x: 0, y: 0 };
        let zoomLevel = 1.0;
        let isPanning = false;
        let lastPanPos = { x: 0, y: 0 };
        
        // Move state
        let isDragging = false;
        let dragStartPos = null;
        let originalWallPos = null;
        
        // Wall stretching state
        let stretchingWall = null;
        let stretchingEndpoint = null; // 'A' or 'B'
        let originalStretchPoint = null;

        // Toast notification system
        function showToast(message, type = 'error', duration = 4000) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            toast.innerHTML = `
                <div class="toast-content">
                    <p class="toast-message">${message}</p>
                </div>
            `;
            
            container.appendChild(toast);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.classList.add('hiding');
                setTimeout(() => {
                    container.removeChild(toast);
                }, 300); // Match animation duration
            }, duration);
            
            // Allow clicking to dismiss
            toast.addEventListener('click', () => {
                toast.classList.add('hiding');
                setTimeout(() => {
                    if (container.contains(toast)) {
                        container.removeChild(toast);
                    }
                }, 300);
            });
        }
        
        // Update or create a persistent toast while drawing (errors only)
        function updateDrawingToast(isRestricted, restriction, wallLength) {
            const container = document.getElementById('toast-container');
            
            if (isRestricted) {
                // Show error toast
                const message = `Cannot place here. Min distance: ${restriction.zone.distance / 10}cm`;
                const type = 'error';
                
                // If toast exists, update it
                if (drawingToastElement && container.contains(drawingToastElement)) {
                    drawingToastElement.className = `toast ${type}`;
                    const messageEl = drawingToastElement.querySelector('.toast-message');
                    if (messageEl) {
                        messageEl.textContent = message;
                    }
                } else {
                    // Create new toast
                    const toast = document.createElement('div');
                    toast.className = `toast ${type}`;
                    
                    toast.innerHTML = `
                        <div class="toast-content">
                            <p class="toast-message">${message}</p>
                        </div>
                    `;
                    
                    container.appendChild(toast);
                    drawingToastElement = toast;
                }
            } else {
                // Valid wall - clear any existing error toast
                clearDrawingToast();
            }
        }
        
        // Clear the drawing toast
        function clearDrawingToast() {
            if (drawingToastElement) {
                const container = document.getElementById('toast-container');
                drawingToastElement.classList.add('hiding');
                const toastToRemove = drawingToastElement;
                drawingToastElement = null;
                setTimeout(() => {
                    if (container.contains(toastToRemove)) {
                        container.removeChild(toastToRemove);
                    }
                }, 300);
            }
        }

        // Redo history
        let redoHistory = [];

        // Undo functionality
        function undo() {
            if (history.length === 0) {
                showToast('Nothing to undo', 'info', 2000);
                return;
            }
            
            // Get the last operation
            const lastOperation = history.pop();
            
            // Remove the walls from this operation
            lastOperation.wallIndices.forEach(index => {
                // Find and remove by comparing wall properties
                // (indices may have shifted, so we match by wall object)
                const wallIndex = walls.indexOf(lastOperation.walls[lastOperation.wallIndices.indexOf(index)]);
                if (wallIndex !== -1) {
                    walls.splice(wallIndex, 1);
                }
            });
            
            // Add to redo history
            redoHistory.push(lastOperation);
            if (redoHistory.length > MAX_HISTORY) {
                redoHistory.shift();
            }
            
            selectedWalls = [];
            updateUI();
            draw();
            
            showToast('Undo', 'info', 2000);
        }

        // Redo functionality
        function redo() {
            if (redoHistory.length === 0) {
                showToast('Nothing to redo', 'info', 2000);
                return;
            }
            
            // Get the last undone operation
            const operation = redoHistory.pop();
            
            // Re-add the walls
            operation.walls.forEach(wall => {
                walls.push(wall);
            });
            
            // Add back to undo history
            addToHistory(operation.walls);
            
            selectedWalls = [];
            updateUI();
            draw();
            
            showToast('Redo', 'info', 2000);
        }

        // Add walls to history
        function addToHistory(addedWalls = []) {
            // If no walls provided, save current state for undo
            const wallsToSave = addedWalls.length > 0 ? addedWalls : [...walls];
            
            const operation = {
                walls: wallsToSave,
                wallIndices: wallsToSave.map(w => walls.indexOf(w)),
                timestamp: Date.now()
            };
            
            history.push(operation);
            
            // Clear redo history when new action is performed
            redoHistory = [];
            
            // Limit history size
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
        }

        // Canvas variables
        let canvas, ctx;
        
        // Initialize everything when DOM is ready
        window.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('mainCanvas');
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                if (canvas.width > 0 && canvas.height > 0) {
                    draw();
                } else {
                    console.error('Canvas has zero dimensions!');
                }
            }
            
            window.addEventListener('resize', resizeCanvas);
            
            // Give the browser time to layout the DOM
            setTimeout(() => {
                resizeCanvas();
                setupEventListeners();
            }, 100);
        });

        // Wall class
        class Wall {
            constructor(ax, ay, bx, by, thickness = 200, height = 2700, groupId = null, floorId = 0) {
                // Points A and B ARE on the INTERNAL face (blue line - grid-aligned with columns)
                // The user draws on the grid lines, which become the internal face
                this.pointA = { x: ax, y: ay }; // Internal face point A (blue line, grid-aligned)
                this.pointB = { x: bx, y: by }; // Internal face point B (blue line, grid-aligned)
                this.thickness = thickness; // mm
                this.height = height; // mm
                this.groupId = groupId; // For tracking segments of the same wall
                this.floorId = floorId; // Which floor this wall belongs to
                this.updateVectors();
            }

            updateVectors() {
                // Direction vector d = AB
                this.d = {
                    x: this.pointB.x - this.pointA.x,
                    y: this.pointB.y - this.pointA.y
                };

                // Length
                this.length = Math.sqrt(this.d.x * this.d.x + this.d.y * this.d.y);

                // Normalized direction (handle zero-length case)
                if (this.length > 0) {
                    this.dNorm = {
                        x: this.d.x / this.length,
                        y: this.d.y / this.length
                    };
                } else {
                    // Default to horizontal for zero-length walls
                    this.dNorm = { x: 1, y: 0 };
                }

                // Normal vector n (perpendicular, pointing INWARD from external face)
                // Right-hand cross product: up × d
                this.n = {
                    x: -this.dNorm.y,
                    y: this.dNorm.x
                };
            }

            getExternalFacePoints() {
                // External face is thickness distance outward from internal face (A and B)
                return {
                    a: {
                        x: this.pointA.x + this.n.x * this.thickness,
                        y: this.pointA.y + this.n.y * this.thickness
                    },
                    b: {
                        x: this.pointB.x + this.n.x * this.thickness,
                        y: this.pointB.y + this.n.y * this.thickness
                    }
                };
            }

            getInternalFacePoints() {
                // Internal face IS points A and B (for backward compatibility)
                return {
                    a: this.pointA,
                    b: this.pointB
                };
            }

            isParallelTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot > 0.999; // Almost parallel
            }

            isPerpendicularTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot < 0.1; // Almost perpendicular
            }

            sameOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot > 0.9;
            }

            oppositeOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot < -0.9;
            }

            overlapsInProjection(other) {
                // Project both walls onto the line direction
                const dir = this.dNorm;
                
                const a1 = this.pointA.x * dir.x + this.pointA.y * dir.y;
                const b1 = this.pointB.x * dir.x + this.pointB.y * dir.y;
                const min1 = Math.min(a1, b1);
                const max1 = Math.max(a1, b1);

                const a2 = other.pointA.x * dir.x + other.pointA.y * dir.y;
                const b2 = other.pointB.x * dir.x + other.pointB.y * dir.y;
                const min2 = Math.min(a2, b2);
                const max2 = Math.max(a2, b2);

                // Allow touching at endpoints (use <= to exclude touching walls)
                // Add small tolerance for floating point comparisons
                const tolerance = 1; // 1mm tolerance
                return !(max1 <= min2 + tolerance || max2 <= min1 + tolerance);
            }

            distanceToWall(other) {
                // Calculate minimum distance between INTERNAL faces (blue lines - column face to column face)
                // v3: Fixed to use infinite line distance for parallel walls - 2024
                
                // For parallel walls, calculate perpendicular distance between the infinite lines
                if (this.isParallelTo(other)) {
                    const internal1 = this.getInternalFacePoints();
                    const internal2 = other.getInternalFacePoints();
                    
                    // For parallel lines, perpendicular distance is constant everywhere
                    // Use cross product method: distance = |ax + by + c| / sqrt(a² + b²)
                    // Or simpler: use perpendicular vector
                    
                    // Get direction vector of wall 2
                    const dx = internal2.b.x - internal2.a.x;
                    const dy = internal2.b.y - internal2.a.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    
                    if (len === 0) {
                        return Math.sqrt(
                            (internal1.a.x - internal2.a.x) ** 2 + 
                            (internal1.a.y - internal2.a.y) ** 2
                        );
                    }
                    
                    // For parallel lines, use the cross product formula
                    // Distance = |cross product| / |direction vector|
                    // For 2D: |(x - x0) × direction| / |direction|
                    // = |dx * (py - y0) - dy * (px - x0)| / sqrt(dx² + dy²)
                    
                    const px = internal1.a.x;
                    const py = internal1.a.y;
                    const x0 = internal2.a.x;
                    const y0 = internal2.a.y;
                    
                    const crossProduct = Math.abs(dx * (py - y0) - dy * (px - x0));
                    const distance = crossProduct / len;
                    return distance;
                }
                
                // For non-parallel walls, calculate minimum distance between segments
                const internal1 = this.getInternalFacePoints();
                const internal2 = other.getInternalFacePoints();

                const distances = [
                    this.pointToLineDistance(internal1.a, internal2.a, internal2.b),
                    this.pointToLineDistance(internal1.b, internal2.a, internal2.b),
                    this.pointToLineDistance(internal2.a, internal1.a, internal1.b),
                    this.pointToLineDistance(internal2.b, internal1.a, internal1.b)
                ];

                return Math.min(...distances);
            }

            pointToLineDistance(point, lineA, lineB) {
                const dx = lineB.x - lineA.x;
                const dy = lineB.y - lineA.y;
                const lenSq = dx * dx + dy * dy;
                
                if (lenSq === 0) return Math.sqrt(
                    (point.x - lineA.x) ** 2 + (point.y - lineA.y) ** 2
                );

                let t = ((point.x - lineA.x) * dx + (point.y - lineA.y) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));

                const projX = lineA.x + t * dx;
                const projY = lineA.y + t * dy;

                return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);
            }

            containsPoint(x, y, tolerance = 10) {
                const internal = this.getInternalFacePoints();
                
                // Check if point is within the wall rectangle (with tolerance)
                const dx = this.pointB.x - this.pointA.x;
                const dy = this.pointB.y - this.pointA.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = -dy / len;
                const ny = dx / len;

                // Create wall rectangle vertices
                const vertices = [
                    this.pointA,
                    this.pointB,
                    internal.b,
                    internal.a
                ];

                return this.isPointInPolygon({ x, y }, vertices, tolerance);
            }

            isPointInPolygon(point, vertices, tolerance) {
                let inside = false;
                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;
                    
                    const intersect = ((yi > point.y) !== (yj > point.y))
                        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                
                // Also check distance to edges
                for (let i = 0; i < vertices.length; i++) {
                    const j = (i + 1) % vertices.length;
                    const dist = this.pointToLineDistance(point, vertices[i], vertices[j]);
                    if (dist < tolerance) return true;
                }
                
                return inside;
            }
        }

        // Grid snapping - snap to 300mm external grid only
        function snapToGrid(value, gridSize = GRID_SIZE_EXTERNAL) {
            return Math.round(value / gridSize) * gridSize;
        }

        function mmToPx(mm) {
            return mm * MM_TO_PX;
        }

        function pxToMm(px) {
            return px / MM_TO_PX;
        }

        function pxSnapToGrid(px, gridSize = GRID_SIZE_EXTERNAL) {
            const mm = pxToMm(px);
            const snappedMm = snapToGrid(mm, gridSize);
            return mmToPx(snappedMm);
        }

        // Drawing functions
        function drawGrid() {
            if (!ctx || !canvas) {
                console.error('Canvas not initialized in drawGrid!');
                return;
            }
            
            // Grid is always shown
            
            const gridStepExternal = mmToPx(GRID_SIZE_EXTERNAL);
            const gridStepInternal = mmToPx(GRID_SIZE_INTERNAL);

            // Calculate visible world bounds (in pixels) accounting for pan/zoom
            const visibleLeft = -panOffset.x / zoomLevel;
            const visibleTop = -panOffset.y / zoomLevel;
            const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
            const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
            
            // Round to grid boundaries
            const startX = Math.floor(visibleLeft / gridStepExternal) * gridStepExternal;
            const endX = Math.ceil(visibleRight / gridStepExternal) * gridStepExternal;
            const startY = Math.floor(visibleTop / gridStepExternal) * gridStepExternal;
            const endY = Math.ceil(visibleBottom / gridStepExternal) * gridStepExternal;

            // Draw 300mm grid (external) - DARK, thicker lines
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2 / zoomLevel; // Adjust line width for zoom
            for (let x = startX; x <= endX; x += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(x, visibleTop);
                ctx.lineTo(x, visibleBottom);
                ctx.stroke();
            }
            for (let y = startY; y <= endY; y += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(visibleLeft, y);
                ctx.lineTo(visibleRight, y);
                ctx.stroke();
            }

            // Draw 100mm grid (internal) - lighter lines
            ctx.strokeStyle = '#dddddd';
            ctx.lineWidth = 0.5 / zoomLevel; // Adjust line width for zoom
            
            const startXInternal = Math.floor(visibleLeft / gridStepInternal) * gridStepInternal;
            const endXInternal = Math.ceil(visibleRight / gridStepInternal) * gridStepInternal;
            const startYInternal = Math.floor(visibleTop / gridStepInternal) * gridStepInternal;
            const endYInternal = Math.ceil(visibleBottom / gridStepInternal) * gridStepInternal;
            
            for (let x = startXInternal; x <= endXInternal; x += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(x % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(x, visibleTop);
                ctx.lineTo(x, visibleBottom);
                ctx.stroke();
            }
            for (let y = startYInternal; y <= endYInternal; y += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(y % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(visibleLeft, y);
                ctx.lineTo(visibleRight, y);
                ctx.stroke();
            }
        }

        function getRestrictedZones(wall) {
            // Show restricted zones from all floors on the current floor
            const zones = [];
            // Internal face is at points A and B (blue line)
            const internalY = wall.pointA.y;
            const internalX = wall.pointA.x;

            // Determine if wall is horizontal or vertical
            const isHorizontal = Math.abs(wall.d.y) < Math.abs(wall.d.x);

            // Calculate truly infinite bounds based on visible area + large margin
            const visibleLeft = -panOffset.x / zoomLevel;
            const visibleTop = -panOffset.y / zoomLevel;
            const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
            const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
            
            // Add large margin to make zones effectively infinite
            const margin = 100000; // 100 meters in pixels
            const infiniteLeft = pxToMm(visibleLeft - margin);
            const infiniteRight = pxToMm(visibleRight + margin);
            const infiniteTop = pxToMm(visibleTop - margin);
            const infiniteBottom = pxToMm(visibleBottom + margin);

            if (isHorizontal) {
                // Horizontal wall - restricted zones extend infinitely along X
                // Internal face is at A-B (y coordinate)
                // Normal vector n points INWARD from external face

                // Zone on internal side (same orientation - toward internal face, direction of n)
                // Same-orientation walls need 600mm clearance on this side
                const parallelY = internalY + (wall.n.y > 0 ? MIN_DISTANCE_PARALLEL : -MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: infiniteLeft,
                    y1: Math.min(internalY, parallelY),
                    x2: infiniteRight,
                    y2: Math.max(internalY, parallelY),
                    distance: MIN_DISTANCE_PARALLEL
                });

                // Zone on external side (opposite orientation - away from internal face, opposite to n)
                // Opposite-orientation walls need 1200mm clearance on this side
                const oppositeY = internalY + (wall.n.y > 0 ? -MIN_DISTANCE_OPPOSITE : MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: infiniteLeft,
                    y1: Math.min(internalY, oppositeY),
                    x2: infiniteRight,
                    y2: Math.max(internalY, oppositeY),
                    distance: MIN_DISTANCE_OPPOSITE
                });
            } else {
                // Vertical wall - restricted zones extend infinitely along Y
                // Internal face is at A-B (x coordinate)
                // Normal vector n points INWARD from external face

                // Zone on internal side (same orientation - toward internal face, direction of n)
                // Same-orientation walls need 600mm clearance on this side
                const parallelX = internalX + (wall.n.x > 0 ? MIN_DISTANCE_PARALLEL : -MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: Math.min(internalX, parallelX),
                    y1: infiniteTop,
                    x2: Math.max(internalX, parallelX),
                    y2: infiniteBottom,
                    distance: MIN_DISTANCE_PARALLEL
                });

                // Zone on external side (opposite orientation - away from internal face, opposite to n)
                // Opposite-orientation walls need 1200mm clearance on this side
                const oppositeX = internalX + (wall.n.x > 0 ? -MIN_DISTANCE_OPPOSITE : MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: Math.min(internalX, oppositeX),
                    y1: infiniteTop,
                    x2: Math.max(internalX, oppositeX),
                    y2: infiniteBottom,
                    distance: MIN_DISTANCE_OPPOSITE
                });
            }

            return zones;
        }

        function drawRestrictedZones() {
            // Restricted zones are always shown
            
            walls.forEach(wall => {
                const zones = getRestrictedZones(wall);
                
                zones.forEach(zone => {
                    ctx.fillStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.1)' :  // Red for opposite (1200mm)
                        'rgba(255, 152, 0, 0.08)';   // Orange for parallel (600mm)
                    
                    ctx.fillRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );

                    // Draw border
                    ctx.strokeStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.3)' : 
                        'rgba(255, 152, 0, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.strokeRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );
                    ctx.setLineDash([]);
                });
            });
        }

        function isWallInRestrictedZone(newWall) {
            for (let existingWall of walls) {
                const onSameFloor = newWall.floorId === existingWall.floorId;
                const onDifferentFloor = newWall.floorId !== existingWall.floorId;
                
                // Check if walls are perpendicular - no restriction
                if (existingWall.isPerpendicularTo(newWall)) {
                    continue;
                }

                // Check if parallel
                if (existingWall.isParallelTo(newWall)) {
                    const dist = newWall.distanceToWall(existingWall);
                    const sameOrientation = newWall.sameOrientation(existingWall);
                    const sameThickness = Math.abs(newWall.thickness - existingWall.thickness) < 1;
                    const hasOverlap = newWall.overlapsInProjection(existingWall);
                    
                    // Check for body overlap (critical for cross-floor walls with opposite orientations)
                    const maxBodyOverlapDist = newWall.thickness + existingWall.thickness + 10; // +10mm tolerance
                    const bodiesOverlap = dist < maxBodyOverlapDist;
                    
                    // Same-floor: Check if aligned (internal faces close together)
                    if (onSameFloor && dist < 10) {
                        // Rule 1: Aligned walls on same floor must share orientation and thickness
                        if (!sameOrientation || !sameThickness) {
                            return {
                                restricted: true,
                                wall: existingWall,
                                zone: { distance: 600, reason: 'Same-floor aligned walls must share orientation and thickness' }
                            };
                        }
                        // Also can't overlap
                        if (hasOverlap) {
                            return {
                                restricted: true,
                                wall: existingWall,
                                zone: { distance: 0, reason: 'Same-floor aligned walls cannot overlap' }
                            };
                        }
                        continue;
                    }
                    
                    // Cross-floor: Check if on same gridline with matching orientation/thickness
                    // These are always allowed, regardless of whether they overlap in projection
                    if (onDifferentFloor && dist < 10 && sameOrientation && sameThickness) {
                        continue; // Same gridline, same orientation/thickness - always valid
                    }
                    
                    // Cross-floor: Check if bodies overlap (regardless of internal face distance)
                    if (onDifferentFloor && hasOverlap && bodiesOverlap) {
                        // Rule 2: Cross-floor overlapping walls must share orientation and thickness
                        if (!sameOrientation || !sameThickness) {
                            return {
                                restricted: true,
                                wall: existingWall,
                                zone: { distance: 600, reason: 'Cross-floor overlap requires matching thickness and orientation' }
                            };
                        }
                        // If orientation and thickness match AND walls are directly on top of each other, allow it
                        if (dist < 10) {
                            continue; // Directly overlapping - valid placement
                        }
                        // If they have matching orientation/thickness but aren't directly overlapping (e.g. 30cm apart),
                        // fall through to check minimum distance requirements
                    }
                    
                    // Non-aligned parallel walls on same floor OR adjacent floors need minimum distance (Rule 3)
                    const floorDiff = Math.abs(newWall.floorId - existingWall.floorId);
                    if (floorDiff <= 1) { // Same floor or adjacent floors (consecutive levels)
                        // Determine minimum distance based on orientation
                        let minDist;
                        if (newWall.oppositeOrientation(existingWall)) {
                            // Opposite orientation: check if facing toward/away
                            const newWallMidX = (newWall.pointA.x + newWall.pointB.x) / 2;
                            const newWallMidY = (newWall.pointA.y + newWall.pointB.y) / 2;
                            const existingWallMidX = (existingWall.pointA.x + existingWall.pointB.x) / 2;
                            const existingWallMidY = (existingWall.pointA.y + existingWall.pointB.y) / 2;
                            
                            const toNewWall = {
                                x: newWallMidX - existingWallMidX,
                                y: newWallMidY - existingWallMidY
                            };
                            
                            const existingToNew = toNewWall.x * existingWall.n.x + toNewWall.y * existingWall.n.y;
                            
                            if (existingToNew > 0) {
                                // Internal faces facing each other: 1200mm
                                minDist = MIN_DISTANCE_OPPOSITE;
                            } else {
                                // Internal faces facing away from each other: 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            }
                        } else {
                            // Same orientation: 600mm
                            minDist = MIN_DISTANCE_PARALLEL;
                        }

                        // Add 2mm tolerance to avoid floating-point precision issues
                        if (dist < minDist - 2) {
                            return { 
                                restricted: true, 
                                wall: existingWall, 
                                zone: { distance: minDist }
                            };
                        }
                    }
                }
            }
            return { restricted: false };
        }

        function drawWall(wall, isSelected = false, violations = [], opacity = 1.0, overrideColor = null) {
            const hasViolation = violations.length > 0;
            const external = wall.getExternalFacePoints();
            
            // Apply opacity for adjacent floor walls
            ctx.globalAlpha = opacity;

            // Draw wall body (from internal face A-B to external face)
            if (overrideColor) {
                ctx.fillStyle = overrideColor.replace(')', ', 0.15)').replace('rgb', 'rgba');
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? 'rgba(244, 67, 54, 0.2)' : 
                               isSelected ? 'rgba(33, 150, 243, 0.3)' : 'rgba(158, 158, 158, 0.3)';
                ctx.strokeStyle = hasViolation ? '#f44336' :
                                 isSelected ? '#2196F3' : '#757575';
            }
            ctx.lineWidth = isSelected ? 3 : 2;

            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw INTERNAL face line (BLUE - grid-aligned side with columns)
            // This is at points A and B
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = '#2196F3';
            }
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.stroke();

            // Draw external face line (thinner, darker)
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = hasViolation ? '#d32f2f' :
                                 isSelected ? '#1976D2' : '#424242';
            }
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.beginPath();
            ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.stroke();

            // Draw steel columns (10x10cm squares at A and B on the BLUE LINE)
            const columnSize = mmToPx(COLUMN_SIZE);
            if (overrideColor) {
                ctx.fillStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? '#f44336' :
                               isSelected ? '#2196F3' : '#616161';
            }

            // Column at A (on internal face - blue line)
            // Position column in grid cell, aligned to internal corner
            // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
            const colAX = wall.pointA.x + (COLUMN_SIZE / 2) * wall.dNorm.x + (COLUMN_SIZE / 2) * wall.n.x;
            const colAY = wall.pointA.y + (COLUMN_SIZE / 2) * wall.dNorm.y + (COLUMN_SIZE / 2) * wall.n.y;
            ctx.fillRect(
                mmToPx(colAX) - columnSize / 2,
                mmToPx(colAY) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Column at B (on internal face - blue line)
            // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
            const colBX = wall.pointB.x - (COLUMN_SIZE / 2) * wall.dNorm.x + (COLUMN_SIZE / 2) * wall.n.x;
            const colBY = wall.pointB.y - (COLUMN_SIZE / 2) * wall.dNorm.y + (COLUMN_SIZE / 2) * wall.n.y;
            ctx.fillRect(
                mmToPx(colBX) - columnSize / 2,
                mmToPx(colBY) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Draw dimensions
            if (isSelected) {
                const midX = (wall.pointA.x + wall.pointB.x) / 2;
                const midY = (wall.pointA.y + wall.pointB.y) / 2;
                
                ctx.fillStyle = '#2196F3';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `${Math.round(wall.length / 10)}cm (${wall.thickness / 10}cm thick)`,
                    mmToPx(midX),
                    mmToPx(midY) - 15
                );
            }
            
            // Reset global alpha
            ctx.globalAlpha = 1.0;
        }

        // Helper function to check if a point is near a wall endpoint
        function getEndpointNearPoint(x, y, threshold = 20) {
            // Transform threshold to world coordinates
            const worldThreshold = threshold / zoomLevel;
            
            for (let wall of walls) {
                // Only check walls on current floor
                if (wall.floorId !== currentFloorId) continue;
                
                // Check point A
                const distA = Math.sqrt(
                    Math.pow(x - wall.pointA.x, 2) + 
                    Math.pow(y - wall.pointA.y, 2)
                );
                if (distA < worldThreshold) {
                    return { wall, endpoint: 'A' };
                }
                
                // Check point B
                const distB = Math.sqrt(
                    Math.pow(x - wall.pointB.x, 2) + 
                    Math.pow(y - wall.pointB.y, 2)
                );
                if (distB < worldThreshold) {
                    return { wall, endpoint: 'B' };
                }
            }
            return null;
        }
        
        function draw() {
            if (!ctx || !canvas) {
                console.error('Canvas not initialized in draw!');
                return;
            }
            
            // Clear and fill background (before transformation)
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply pan and zoom transformation
            ctx.setTransform(zoomLevel, 0, 0, zoomLevel, panOffset.x, panOffset.y);
            
            drawGrid();

            // Draw walls from levels below if enabled
            if (document.getElementById('showOtherFloors').checked) {
                walls.forEach((wall, idx) => {
                    // Only show levels below the current level
                    if (wall.floorId < currentFloorId) {
                        // Calculate opacity based on distance from current level
                        // 1 level below = 0.4 opacity, 2 levels = 0.25, 3 levels = 0.15, etc.
                        const floorsBelow = currentFloorId - wall.floorId;
                        const opacity = Math.max(0.1, 0.5 - (floorsBelow * 0.15));
                        
                        // Lighter gray color for trace
                        drawWall(wall, false, [], opacity, '#90A4AE');
                    }
                });
            }
            
            // Draw walls from levels above if enabled (draw early so they don't get covered)
            const showLevelsAboveCheckbox = document.getElementById('showLevelsAbove');
            if (showLevelsAboveCheckbox && showLevelsAboveCheckbox.checked) {
                walls.forEach((wall, idx) => {
                    // Only show levels above the current level
                    if (wall.floorId > currentFloorId) {
                        // Calculate opacity based on distance from current level
                        const floorsAbove = wall.floorId - currentFloorId;
                        
                        // Get wall faces
                        const external = wall.getExternalFacePoints();
                        
                        // Draw filled rectangle with very faint light grey
                        // Use much lower opacity for fill (0.15 for 1 level above)
                        const fillOpacity = Math.max(0.08, 0.15 - (floorsAbove * 0.04));
                        ctx.globalAlpha = fillOpacity;
                        ctx.fillStyle = '#B0BEC5'; // Light blue-grey fill
                        
                        ctx.beginPath();
                        ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
                        ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
                        ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                        ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw dashed outline with higher opacity for visibility
                        const outlineOpacity = Math.max(0.2, 0.4 - (floorsAbove * 0.1));
                        ctx.globalAlpha = outlineOpacity;
                        ctx.strokeStyle = '#607D8B'; // Darker blue-grey outline
                        ctx.lineWidth = 2 / zoomLevel;
                        ctx.setLineDash([8 / zoomLevel, 8 / zoomLevel]);
                        ctx.stroke();
                        
                        ctx.setLineDash([]);
                        ctx.globalAlpha = 1.0;
                    }
                });
            }
            
            // Track walls generating restriction zones (for pulsing effect while drawing)
            const restrictingWalls = new Set();
            
            // Get current level walls
            const currentFloorWalls = walls.filter(w => w.floorId === currentFloorId);

            // Get violations for current level walls
            const wallViolations = new Map();
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId || 
                    wall.floorId === currentFloorId - 1 || 
                    wall.floorId === currentFloorId + 1) {
                    wallViolations.set(idx, validateWall(wall, idx));
                }
            });

            // Draw current level walls
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId) {
                    const isSelected = selectedWalls.includes(wall);
                    const violations = wallViolations.get(idx) || [];
                    drawWall(wall, isSelected, violations);
                }
            });
            
            // Draw endpoint handles in select mode (only for selected walls)
            if (currentMode === 'select' && selectedWalls.length > 0) {
                selectedWalls.forEach((wall) => {
                    if (wall.floorId === currentFloorId) {
                        ctx.save();
                        
                        // Check if mouse is near endpoints for hover highlighting
                        let nearA = false;
                        let nearB = false;
                        if (currentMousePos) {
                            const worldThreshold = 20 / zoomLevel;
                            const distA = Math.sqrt(
                                Math.pow(currentMousePos.x - wall.pointA.x, 2) + 
                                Math.pow(currentMousePos.y - wall.pointA.y, 2)
                            );
                            const distB = Math.sqrt(
                                Math.pow(currentMousePos.x - wall.pointB.x, 2) + 
                                Math.pow(currentMousePos.y - wall.pointB.y, 2)
                            );
                            nearA = distA < worldThreshold;
                            nearB = distB < worldThreshold;
                        }
                        
                        // Draw point A handle
                        ctx.beginPath();
                        ctx.arc(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y), 8 / zoomLevel, 0, Math.PI * 2);
                        ctx.fillStyle = nearA ? '#2563eb' : 'rgba(37, 99, 235, 0.5)';
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2 / zoomLevel;
                        ctx.stroke();
                        
                        // Draw point B handle
                        ctx.beginPath();
                        ctx.arc(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y), 8 / zoomLevel, 0, Math.PI * 2);
                        ctx.fillStyle = nearB ? '#2563eb' : 'rgba(37, 99, 235, 0.5)';
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2 / zoomLevel;
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
            }

            // Draw temporary wall while drawing
            if (drawingWall && tempPoint && (drawingWall.x !== tempPoint.x || drawingWall.y !== tempPoint.y)) {
                // Apply flip by swapping start/end if flipped
                const startX = wallFlipped ? tempPoint.x : drawingWall.x;
                const startY = wallFlipped ? tempPoint.y : drawingWall.y;
                const endX = wallFlipped ? drawingWall.x : tempPoint.x;
                const endY = wallFlipped ? drawingWall.y : tempPoint.y;
                
                const tempWall = new Wall(
                    startX,
                    startY,
                    endX,
                    endY,
                    parseInt(document.getElementById('wallThickness').value),
                    2700, // Default height
                    null, // No groupId for preview
                    currentFloorId // Preview on current floor
                );
                
                // Draw dynamic restriction zones based on preview wall's orientation
                if (tempWall.length > 0) {
                    walls.forEach((existingWall, idx) => {
                        // Check walls on current floor and adjacent floors (consecutive levels)
                        const floorDiff = Math.abs(existingWall.floorId - currentFloorId);
                        if (floorDiff > 1) {
                            return;
                        }
                        
                        // Only draw zones for parallel walls
                        const isParallel = existingWall.isParallelTo(tempWall);
                        if (!isParallel) return;
                        
                        // Calculate preview midpoint (used for both special case and general case)
                        const previewMidX = (tempWall.pointA.x + tempWall.pointB.x) / 2;
                        const previewMidY = (tempWall.pointA.y + tempWall.pointB.y) / 2;
                        
                        // Check if walls are aligned (same line AND same orientation)
                        const dist = tempWall.distanceToWall(existingWall);
                        if (dist < 10) {
                            // On same line - check orientation
                            const sameOrientation = tempWall.sameOrientation(existingWall);
                            if (sameOrientation) {
                                return;
                            }
                            // Same line but OPPOSITE orientation - INVALID at 0mm!
                            // When walls are on the same line with opposite orientation,
                            // moving perpendicular creates "facing away" configuration = 600mm minimum
                            const requiredDistance = MIN_DISTANCE_PARALLEL; // 600mm (internal faces point away)
                            
                            // Mark this wall as generating a restriction zone
                            restrictingWalls.add(idx);
                            
                            ctx.fillStyle = 'rgba(244, 67, 54, 0.12)'; // Red
                            
                            const isHorizontal = Math.abs(existingWall.d.y) < Math.abs(existingWall.d.x);
                            const internalY = existingWall.pointA.y;
                            const internalX = existingWall.pointA.x;
                            
                            const visibleLeft = (-panOffset.x) / zoomLevel;
                            const visibleTop = (-panOffset.y) / zoomLevel;
                            const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
                            const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
                            const margin = 100000;
                            const infiniteLeft = pxToMm(visibleLeft - margin);
                            const infiniteRight = pxToMm(visibleRight + margin);
                            const infiniteTop = pxToMm(visibleTop - margin);
                            const infiniteBottom = pxToMm(visibleBottom + margin);
                            
                            if (isHorizontal) {
                                // Determine if preview is above or below existing wall
                                if (previewMidY > internalY) {
                                    // Preview is below - draw zone below
                                    ctx.fillRect(
                                        mmToPx(infiniteLeft),
                                        mmToPx(internalY),
                                        mmToPx(infiniteRight - infiniteLeft),
                                        mmToPx(requiredDistance)
                                    );
                                } else {
                                    // Preview is above - draw zone above
                                    ctx.fillRect(
                                        mmToPx(infiniteLeft),
                                        mmToPx(internalY - requiredDistance),
                                        mmToPx(infiniteRight - infiniteLeft),
                                        mmToPx(requiredDistance)
                                    );
                                }
                            } else {
                                // Determine if preview is left or right of existing wall
                                if (previewMidX > internalX) {
                                    // Preview is to the right - draw zone right
                                    ctx.fillRect(
                                        mmToPx(internalX),
                                        mmToPx(infiniteTop),
                                        mmToPx(requiredDistance),
                                        mmToPx(infiniteBottom - infiniteTop)
                                    );
                                } else {
                                    // Preview is to the left - draw zone left
                                    ctx.fillRect(
                                        mmToPx(internalX - requiredDistance),
                                        mmToPx(infiniteTop),
                                        mmToPx(requiredDistance),
                                        mmToPx(infiniteBottom - infiniteTop)
                                    );
                                }
                            }
                            return; // Done drawing zone for this wall
                        }
                        
                        // Determine which side of the existing wall the preview wall is on
                        // (previewMidX/Y already calculated above)
                        
                        // Vector from existing wall's internal face to preview wall midpoint
                        const toPreview = {
                            x: previewMidX - existingWall.pointA.x,
                            y: previewMidY - existingWall.pointA.y
                        };
                        
                        // Skip if walls are perpendicular (no parallel distance rule)
                        if (!tempWall.isParallelTo(existingWall)) {
                            return;
                        }
                        
                        // Skip if walls are aligned (on same line) - aligned walls are allowed
                        const distanceAtoLine = tempWall.pointToLineDistance(
                            tempWall.pointA, existingWall.pointA, existingWall.pointB
                        );
                        if (distanceAtoLine < 1) { // Aligned (within 1mm tolerance)
                            return;
                        }
                        
                        // Calculate actual distance between walls
                        const actualDistance = tempWall.distanceToWall(existingWall);
                        
                        // Determine the required distance based on orientation
                        const orientationDot = tempWall.n.x * existingWall.n.x + tempWall.n.y * existingWall.n.y;
                        let requiredDistance;
                        
                        // Check if walls have opposite normals
                        if (orientationDot < -0.9) {
                            // Walls are anti-parallel. Now check if internal faces are facing TOWARD each other
                            // Vector from existing wall to preview wall
                            const toPreviewWall = {
                                x: previewMidX - existingWall.pointA.x,
                                y: previewMidY - existingWall.pointA.y
                            };
                            
                            // If existing wall's normal points toward preview (dot > 0), 
                            // and preview wall's normal points toward existing (opposite direction),
                            // then internal faces are facing each other = 1200mm rule
                            const existingToPreview = toPreviewWall.x * existingWall.n.x + toPreviewWall.y * existingWall.n.y;
                            
                            if (existingToPreview > 0) {
                                // Internal faces facing each other: 1200mm
                                requiredDistance = MIN_DISTANCE_OPPOSITE;
                            } else {
                                // Internal faces facing away from each other: 600mm
                                requiredDistance = MIN_DISTANCE_PARALLEL;
                            }
                        } else {
                            // Same orientation or not truly anti-parallel: 600mm
                            requiredDistance = MIN_DISTANCE_PARALLEL;
                        }
                        
                        // Only show zone if preview wall would violate the distance rule
                        // Add 2mm tolerance to match validation logic
                        if (actualDistance >= requiredDistance - 2) {
                            return; // Skip this wall - no violation risk
                        }
                        
                        // Mark this wall as generating a restriction zone
                        restrictingWalls.add(idx);
                        
                        // All zones are RED
                        const zoneColor = 'rgba(244, 67, 54, 0.12)';
                        
                        // Calculate truly infinite bounds
                        const visibleLeft = -panOffset.x / zoomLevel;
                        const visibleTop = -panOffset.y / zoomLevel;
                        const visibleRight = (canvas.width - panOffset.x) / zoomLevel;
                        const visibleBottom = (canvas.height - panOffset.y) / zoomLevel;
                        const margin = 100000;
                        const infiniteLeft = pxToMm(visibleLeft - margin);
                        const infiniteRight = pxToMm(visibleRight + margin);
                        const infiniteTop = pxToMm(visibleTop - margin);
                        const infiniteBottom = pxToMm(visibleBottom + margin);
                        
                        // Determine which side of the existing wall the preview is on
                        // using the normal vector of the existing wall
                        const sideDot = toPreview.x * existingWall.n.x + toPreview.y * existingWall.n.y;
                        
                        // sideDot > 0: preview is on the internal side (direction of normal)
                        // sideDot < 0: preview is on the external side (opposite to normal)
                        
                        const isHorizontal = Math.abs(existingWall.d.y) < Math.abs(existingWall.d.x);
                        
                        ctx.fillStyle = zoneColor;
                        
                        if (isHorizontal) {
                            // Horizontal wall - zone extends vertically
                            // Internal face is at pointA.y
                            // Normal points perpendicular to the wall (up or down)
                            const internalY = existingWall.pointA.y;
                            
                            // Determine zone direction based on where preview is relative to internal face
                            // For horizontal walls, check if preview is above or below
                            if (previewMidY > internalY) {
                                // Preview is below internal face - zone extends downward
                                ctx.fillRect(
                                    mmToPx(infiniteLeft),
                                    mmToPx(internalY),
                                    mmToPx(infiniteRight - infiniteLeft),
                                    mmToPx(requiredDistance)
                                );
                            } else {
                                // Preview is above internal face - zone extends upward
                                ctx.fillRect(
                                    mmToPx(infiniteLeft),
                                    mmToPx(internalY - requiredDistance),
                                    mmToPx(infiniteRight - infiniteLeft),
                                    mmToPx(requiredDistance)
                                );
                            }
                        } else {
                            // Vertical wall - zone extends horizontally
                            // Internal face is at pointA.x
                            // Normal points perpendicular to the wall (left or right)
                            const internalX = existingWall.pointA.x;
                            
                            // Determine zone direction based on where preview is relative to internal face
                            // For vertical walls, check if preview is left or right
                            if (previewMidX > internalX) {
                                // Preview is to the right of internal face - zone extends right
                                ctx.fillRect(
                                    mmToPx(internalX),
                                    mmToPx(infiniteTop),
                                    mmToPx(requiredDistance),
                                    mmToPx(infiniteBottom - infiniteTop)
                                );
                            } else {
                                // Preview is to the left of internal face - zone extends left
                                ctx.fillRect(
                                    mmToPx(internalX - requiredDistance),
                                    mmToPx(infiniteTop),
                                    mmToPx(requiredDistance),
                                    mmToPx(infiniteBottom - infiniteTop)
                                );
                            }
                        }
                    });
                }
                
                // Check if wall is in restricted zone
                const restriction = isWallInRestrictedZone(tempWall);
                const isRestricted = restriction.restricted;
                
                // Draw the preview wall
                {
                    const segment = tempWall;
                    const external = segment.getExternalFacePoints();
                
                    // Draw full wall preview (semi-transparent)
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.2)' : 'rgba(76, 175, 80, 0.2)';
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Draw INTERNAL face (BLUE - grid-aligned side with columns)
                    // This is at points A and B (the grid line)
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.stroke();

                    // Draw external face (dashed)
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw steel column previews at A and B (on the BLUE LINE)
                    const columnSize = mmToPx(COLUMN_SIZE);
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.5)' : 'rgba(76, 175, 80, 0.5)';
                    
                    // Column at A (on internal face - blue line)
                    // Position column in grid cell, aligned to internal corner
                    // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
                    const colAX = segment.pointA.x + (COLUMN_SIZE / 2) * segment.dNorm.x + (COLUMN_SIZE / 2) * segment.n.x;
                    const colAY = segment.pointA.y + (COLUMN_SIZE / 2) * segment.dNorm.y + (COLUMN_SIZE / 2) * segment.n.y;
                    ctx.fillRect(
                        mmToPx(colAX) - columnSize / 2,
                        mmToPx(colAY) - columnSize / 2,
                        columnSize,
                        columnSize
                    );
                    
                    // Column at B (on internal face - blue line)
                    // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
                    const colBX = segment.pointB.x - (COLUMN_SIZE / 2) * segment.dNorm.x + (COLUMN_SIZE / 2) * segment.n.x;
                    const colBY = segment.pointB.y - (COLUMN_SIZE / 2) * segment.dNorm.y + (COLUMN_SIZE / 2) * segment.n.y;
                    ctx.fillRect(
                        mmToPx(colBX) - columnSize / 2,
                        mmToPx(colBY) - columnSize / 2,
                        columnSize,
                        columnSize
                    );

                }

                // Draw start and end points
                ctx.fillStyle = isRestricted ? '#f44336' : '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(mmToPx(tempPoint.x), mmToPx(tempPoint.y), 6, 0, Math.PI * 2);
                ctx.fill();

                // Update drawing toast with current status
                updateDrawingToast(isRestricted, restriction, tempWall.length);
            }

            // Show starting point when first click is placed but no preview yet
            if (drawingWall && (!tempPoint || (drawingWall.x === tempPoint.x && drawingWall.y === tempPoint.y))) {
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw pulsing ring
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 12, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw pulsing red overlay on walls generating restriction zones
            if (drawingWall && restrictingWalls.size > 0) {
                // Calculate pulse opacity using sine wave (0.3 to 0.6 range)
                const time = Date.now() / 1000; // Convert to seconds
                const pulseOpacity = 0.45 + Math.sin(time * 3) * 0.15; // 3 Hz frequency
                
                ctx.globalAlpha = pulseOpacity;
                ctx.fillStyle = '#ef4444'; // Red color
                
                restrictingWalls.forEach(wallIdx => {
                    const wall = walls[wallIdx];
                    if (!wall) return;
                    
                    const external = wall.getExternalFacePoints();
                    
                    // Draw filled rectangle overlay
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
                    ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.closePath();
                    ctx.fill();
                });
                
                ctx.globalAlpha = 1.0;
                
                // Request animation frame to continue pulsing
                requestAnimationFrame(draw);
            }
            
            // Show snap indicator when hovering and ready to start drawing
            if (currentMousePos && currentMode === 'draw' && !drawingWall) {
                drawSnapIndicator(currentMousePos.x, currentMousePos.y);
            }
        }

        // Validation functions
        function validateWall(wall, wallIndex) {
            const violations = [];

            // Check length
            if (wall.length < MIN_WALL_LENGTH) {
                violations.push({
                    type: 'error',
                    message: `Wall is too short (${Math.round(wall.length / 10)}cm). Minimum: ${MIN_WALL_LENGTH / 10}cm`
                });
            }

            // Check against other walls
            walls.forEach((otherWall, otherIndex) => {
                if (wallIndex === otherIndex) return;
                
                // Skip validation between segments of the same wall (auto-split)
                if (wall.groupId && wall.groupId === otherWall.groupId) return;
                
                // Determine if walls are on same level or adjacent levels
                const onSameFloor = wall.floorId === otherWall.floorId;
                const onAdjacentFloors = Math.abs(wall.floorId - otherWall.floorId) === 1;

                // SAME LEVEL RULES (Rule 1 & 3)
                if (onSameFloor) {
                    // Check if walls are parallel
                    if (wall.isParallelTo(otherWall)) {
                        const dist = wall.distanceToWall(otherWall);
                        
                        if (dist < 10) { // Aligned (on same line)
                            // Rule 1: Aligned walls cannot overlap and must share orientation and thickness
                            if (wall.overlapsInProjection(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls overlap with Wall ${otherIndex + 1}`
                                });
                            }

                            if (!wall.sameOrientation(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share orientation with Wall ${otherIndex + 1}`
                                });
                            }

                            if (wall.thickness !== otherWall.thickness) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share thickness with Wall ${otherIndex + 1}`
                                });
                            }
                        } else {
                            // Rule 3a: Parallel walls minimum distance
                            // Check if internal faces are facing toward each other (opposite orientation)
                            let minDist;
                            if (wall.oppositeOrientation(otherWall)) {
                                // Opposite orientation: need to check if facing toward/away
                                // Facing toward = internal faces point toward each other = 1200mm
                                // Facing away = internal faces point away from each other = 600mm
                                
                                // Get midpoint of each wall
                                const wall1Mid = {
                                    x: (wall.pointA.x + wall.pointB.x) / 2,
                                    y: (wall.pointA.y + wall.pointB.y) / 2
                                };
                                const wall2Mid = {
                                    x: (otherWall.pointA.x + otherWall.pointB.x) / 2,
                                    y: (otherWall.pointA.y + otherWall.pointB.y) / 2
                                };
                                
                                // Vector from wall1 to wall2
                                const toOther = {
                                    x: wall2Mid.x - wall1Mid.x,
                                    y: wall2Mid.y - wall1Mid.y
                                };
                                
                                // Dot product of wall1's normal with direction to wall2
                                const dot1 = wall.n.x * toOther.x + wall.n.y * toOther.y;
                                
                                if (dot1 > 0) {
                                    // wall1's internal face points toward wall2 = facing toward each other
                                    minDist = MIN_DISTANCE_OPPOSITE; // 1200mm
                                } else {
                                    // wall1's internal face points away from wall2 = facing away
                                    minDist = MIN_DISTANCE_PARALLEL; // 600mm
                                }
                            } else {
                                // Same orientation: 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            }

                            // Add 2mm tolerance to avoid floating-point precision issues
                            if (dist < minDist - 2) {
                                violations.push({
                                    type: 'error',
                                    message: `Too close to Wall ${otherIndex + 1} (${Math.round(dist / 10)}cm). Minimum: ${minDist / 10}cm`
                                });
                            }
                        }
                    }
                    // Rule 3b: Perpendicular walls have no minimum distance requirement
                }
                
                // DIFFERENT LEVEL RULES (Rule 2 & Rule 3 across levels)
                else if (onAdjacentFloors) {
                    // Check if walls are parallel
                    if (wall.isParallelTo(otherWall)) {
                        const dist = wall.distanceToWall(otherWall);
                        
                        // If overlapping (aligned on same line)
                        if (dist < 10) {
                            if (wall.overlapsInProjection(otherWall)) {
                                // Rule 2: Overlapping segments must share orientation and thickness
                                if (!wall.sameOrientation(otherWall)) {
                                    violations.push({
                                        type: 'error',
                                        message: `Overlapping wall on different floor (Wall ${otherIndex + 1}) must share orientation`
                                    });
                                }

                                if (wall.thickness !== otherWall.thickness) {
                                    violations.push({
                                        type: 'error',
                                        message: `Overlapping wall on different floor (Wall ${otherIndex + 1}) must share thickness`
                                    });
                                }
                            }
                        } else {
                            // Rule 3: Distance restrictions apply across consecutive floors too
                            let minDist;
                            if (wall.oppositeOrientation(otherWall)) {
                                // Opposite orientation: check if facing toward/away
                                const wall1Mid = {
                                    x: (wall.pointA.x + wall.pointB.x) / 2,
                                    y: (wall.pointA.y + wall.pointB.y) / 2
                                };
                                const wall2Mid = {
                                    x: (otherWall.pointA.x + otherWall.pointB.x) / 2,
                                    y: (otherWall.pointA.y + otherWall.pointB.y) / 2
                                };
                                
                                const toOther = {
                                    x: wall2Mid.x - wall1Mid.x,
                                    y: wall2Mid.y - wall1Mid.y
                                };
                                
                                const dot1 = wall.n.x * toOther.x + wall.n.y * toOther.y;
                                
                                if (dot1 > 0) {
                                    minDist = MIN_DISTANCE_OPPOSITE; // 1200mm
                                } else {
                                    minDist = MIN_DISTANCE_PARALLEL; // 600mm
                                }
                            } else {
                                // Same orientation: 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            }

                            // Add 2mm tolerance
                            if (dist < minDist - 2) {
                                violations.push({
                                    type: 'error',
                                    message: `Too close to Wall ${otherIndex + 1} on adjacent floor (${Math.round(dist / 10)}cm). Minimum: ${minDist / 10}cm`
                                });
                            }
                        }
                    }
                }
            });

            return violations;
        }

        function validateAllWalls() {
            const allViolations = [];
            
            walls.forEach((wall, idx) => {
                const violations = validateWall(wall, idx);
                if (violations.length > 0) {
                    allViolations.push({
                        wallIndex: idx,
                        violations: violations
                    });
                }
            });

            // displayViolations removed as validation results panel no longer exists
            draw();
        }

        function displayViolations(allViolations) {
            // This function is deprecated - validation results panel was removed
            return;
            
            if (allViolations.length === 0) {
                violationsList.innerHTML = '<div class="no-violations">✓ All rules satisfied!</div>';
                return;
            }

            let html = '';
            allViolations.forEach(({ wallIndex, violations }) => {
                violations.forEach(v => {
                    html += `
                        <div class="violation-item ${v.type}">
                            <div class="violation-title">Wall ${wallIndex + 1}: ${v.type.toUpperCase()}</div>
                            <div>${v.message}</div>
                        </div>
                    `;
                });
            });

            violationsList.innerHTML = html;
        }

        // Mouse handling
        let currentMousePos = null;

        function getMousePosition(e) {
            const rect = canvas.getBoundingClientRect();
            // Get mouse position in canvas pixels
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            
            // Transform from screen space to world space (inverse of pan/zoom)
            const worldX = (canvasX - panOffset.x) / zoomLevel;
            const worldY = (canvasY - panOffset.y) / zoomLevel;
            
            // Convert to mm
            let x = pxToMm(worldX);
            let y = pxToMm(worldY);

            // Always snap to 300mm external grid
            x = snapToGrid(x, GRID_SIZE_EXTERNAL);
            y = snapToGrid(y, GRID_SIZE_EXTERNAL);

            return { x, y };
        }

        function drawSnapIndicator(x, y) {
            // Draw a small circle at snap point
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.arc(mmToPx(x), mmToPx(y), 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw crosshair
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 1;
            const size = 8;
            ctx.beginPath();
            ctx.moveTo(mmToPx(x) - size, mmToPx(y));
            ctx.lineTo(mmToPx(x) + size, mmToPx(y));
            ctx.moveTo(mmToPx(x), mmToPx(y) - size);
            ctx.lineTo(mmToPx(x), mmToPx(y) + size);
            ctx.stroke();
        }

        function setupEventListeners() {
        // Pan and Zoom event listeners
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Zoom in/out (reduced sensitivity)
            const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
            const newZoom = Math.max(0.5, Math.min(2, zoomLevel * zoomFactor));
            
            // Zoom toward mouse position
            const worldXBefore = (mouseX - panOffset.x) / zoomLevel;
            const worldYBefore = (mouseY - panOffset.y) / zoomLevel;
            
            zoomLevel = newZoom;
            
            panOffset.x = mouseX - worldXBefore * zoomLevel;
            panOffset.y = mouseY - worldYBefore * zoomLevel;
            
            draw();
        }, { passive: false });
        
        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = currentMode === 'draw' ? 'crosshair' : 'pointer';
            }
            
            if (stretchingWall) {
                // Check minimum length
                if (stretchingWall.length < MIN_WALL_LENGTH) {
                    // Restore original position
                    stretchingWall.pointA = { x: originalStretchPoint.ax, y: originalStretchPoint.ay };
                    stretchingWall.pointB = { x: originalStretchPoint.bx, y: originalStretchPoint.by };
                    stretchingWall.updateVectors();
                    showToast(`Wall is too short. Minimum length is ${MIN_WALL_LENGTH / 10}cm`, 'error');
                } else {
                    // Check if the stretched wall passes validation
                    const violations = validateWall(walls.indexOf(stretchingWall));
                    if (violations.length > 0 && violations.some(v => v.type === 'error')) {
                        // Restore original position
                        stretchingWall.pointA = { x: originalStretchPoint.ax, y: originalStretchPoint.ay };
                        stretchingWall.pointB = { x: originalStretchPoint.bx, y: originalStretchPoint.by };
                        stretchingWall.updateVectors();
                        showToast('Cannot stretch wall here. Placement would violate rules.', 'error');
                    } else {
                        // Valid stretch - save to history and deselect
                        addToHistory();
                        selectedWalls = [];
                    }
                }
                
                stretchingWall = null;
                stretchingEndpoint = null;
                originalStretchPoint = null;
                canvas.style.cursor = 'pointer';
                validateAllWalls();
                draw();
            }
            
            if (isDragging) {
                // Check if wall was actually moved
                const selectedWall = selectedWalls[0];
                const wasMoved = selectedWall && (
                    selectedWall.pointA.x !== originalWallPos.ax ||
                    selectedWall.pointA.y !== originalWallPos.ay ||
                    selectedWall.pointB.x !== originalWallPos.bx ||
                    selectedWall.pointB.y !== originalWallPos.by
                );
                
                isDragging = false;
                canvas.style.cursor = 'pointer';
                dragStartPos = null;
                originalWallPos = null;
                
                // Only deselect if wall was actually moved
                if (wasMoved) {
                    selectedWalls = [];
                }
                
                validateAllWalls();
                draw();
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - lastPanPos.x;
                const dy = e.clientY - lastPanPos.y;
                panOffset.x += dx;
                panOffset.y += dy;
                lastPanPos = { x: e.clientX, y: e.clientY };
                draw();
                return;
            }
            
            const pos = getMousePosition(e);
            currentMousePos = pos;

            // Handle wall stretching
            if (currentMode === 'select' && stretchingWall) {
                // Constrain to wall's axis (horizontal or vertical)
                const isHorizontal = Math.abs(originalStretchPoint.bx - originalStretchPoint.ax) > 
                                    Math.abs(originalStretchPoint.by - originalStretchPoint.ay);
                
                let newPoint;
                if (isHorizontal) {
                    // Horizontal wall - only allow X movement
                    newPoint = {
                        x: snapToGrid(pos.x, GRID_SIZE_EXTERNAL),
                        y: stretchingEndpoint === 'A' ? originalStretchPoint.ay : originalStretchPoint.by
                    };
                } else {
                    // Vertical wall - only allow Y movement
                    newPoint = {
                        x: stretchingEndpoint === 'A' ? originalStretchPoint.ax : originalStretchPoint.bx,
                        y: snapToGrid(pos.y, GRID_SIZE_EXTERNAL)
                    };
                }
                
                // Update the endpoint being stretched
                if (stretchingEndpoint === 'A') {
                    stretchingWall.pointA = newPoint;
                } else {
                    stretchingWall.pointB = newPoint;
                }
                
                stretchingWall.updateVectors();
                draw();
                return;
            }

            if (currentMode === 'select' && isDragging && selectedWalls.length === 1) {
                // Calculate offset from drag start
                const offsetX = pos.x - dragStartPos.x;
                const offsetY = pos.y - dragStartPos.y;
                
                // Snap offset to grid
                const snappedOffsetX = snapToGrid(offsetX, GRID_SIZE_EXTERNAL);
                const snappedOffsetY = snapToGrid(offsetY, GRID_SIZE_EXTERNAL);
                
                // Update wall position
                const selectedWall = selectedWalls[0];
                selectedWall.pointA.x = originalWallPos.ax + snappedOffsetX;
                selectedWall.pointA.y = originalWallPos.ay + snappedOffsetY;
                selectedWall.pointB.x = originalWallPos.bx + snappedOffsetX;
                selectedWall.pointB.y = originalWallPos.by + snappedOffsetY;
                selectedWall.updateVectors();
                
                draw();
                return;
            }

            if (currentMode === 'draw' && drawingWall) {
                // Constrain to horizontal or vertical only
                const dx = Math.abs(pos.x - drawingWall.x);
                const dy = Math.abs(pos.y - drawingWall.y);
                
                if (dx > dy) {
                    // Horizontal wall
                    tempPoint = { x: pos.x, y: drawingWall.y };
                } else {
                    // Vertical wall
                    tempPoint = { x: drawingWall.x, y: pos.y };
                }
            }
            draw();
        });

        canvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = currentMode === 'draw' ? 'crosshair' : 'pointer';
            }
            
            if (stretchingWall) {
                // Restore original position if user leaves canvas while stretching
                stretchingWall.pointA = { x: originalStretchPoint.ax, y: originalStretchPoint.ay };
                stretchingWall.pointB = { x: originalStretchPoint.bx, y: originalStretchPoint.by };
                stretchingWall.updateVectors();
                stretchingWall = null;
                stretchingEndpoint = null;
                originalStretchPoint = null;
            }
            
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'pointer';
                dragStartPos = null;
                originalWallPos = null;
            }
            
            currentMousePos = null;
            draw();
        });

        canvas.addEventListener('mousedown', (e) => {
            // Check for panning first
            if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
                // Middle mouse or Ctrl+Left mouse for panning
                isPanning = true;
                lastPanPos = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
                return;
            }
            
            const pos = getMousePosition(e);

            if (currentMode === 'draw') {
                if (!drawingWall) {
                    // Start drawing
                    drawingWall = pos;
                    tempPoint = pos;
                } else {
                    // Finish drawing
                    const thickness = parseInt(document.getElementById('wallThickness').value);
                    const height = 2700; // Default height
                    
                    // Constrain to horizontal or vertical
                    const dx = Math.abs(pos.x - drawingWall.x);
                    const dy = Math.abs(pos.y - drawingWall.y);
                    let finalPos = pos;
                    if (dx > dy) {
                        finalPos = { x: pos.x, y: drawingWall.y };
                    } else {
                        finalPos = { x: drawingWall.x, y: pos.y };
                    }
                    
                    // Apply flip by swapping start/end if flipped
                    const startX = wallFlipped ? finalPos.x : drawingWall.x;
                    const startY = wallFlipped ? finalPos.y : drawingWall.y;
                    const endX = wallFlipped ? drawingWall.x : finalPos.x;
                    const endY = wallFlipped ? drawingWall.y : finalPos.y;
                    
                    const newWall = new Wall(
                        startX,
                        startY,
                        endX,
                        endY,
                        thickness,
                        height,
                        null, // No groupId for single walls
                        currentFloorId // Assign to current floor
                    );

                    if (newWall.length < MIN_WALL_LENGTH) {
                        showToast(`Wall is too short. Minimum length is ${MIN_WALL_LENGTH / 10}cm`, 'error');
                        drawingWall = null;
                        tempPoint = null;
                        clearDrawingToast();
                        draw();
                        return;
                    }

                    // Check if wall is in restricted zone
                    const restriction = isWallInRestrictedZone(newWall);
                    if (restriction.restricted) {
                        let message = 'Cannot place wall here.';
                        if (restriction.zone.reason) {
                            message += ` ${restriction.zone.reason}`;
                        } else if (restriction.zone.distance) {
                            message += ` Too close to existing wall. Minimum distance required: ${restriction.zone.distance / 10}cm`;
                        }
                        showToast(message, 'error');
                        drawingWall = null;
                        tempPoint = null;
                        clearDrawingToast();
                        draw();
                        return;
                    }

                    // Add wall to walls array
                    walls.push(newWall);
                    
                    // Add to history for undo
                    addToHistory([newWall]);
                    
                    drawingWall = null;
                    tempPoint = null;
                    wallFlipped = false; // Reset flip state
                    clearDrawingToast();
                    updateUI();
                    validateAllWalls();
                }
            } else if (currentMode === 'select') {
                // Check if clicked near an endpoint of a SELECTED wall (for stretching)
                const endpointHit = getEndpointNearPoint(pos.x, pos.y);
                
                if (endpointHit && selectedWalls.includes(endpointHit.wall)) {
                    // Start stretching (only if wall is already selected)
                    stretchingWall = endpointHit.wall;
                    stretchingEndpoint = endpointHit.endpoint;
                    originalStretchPoint = {
                        ax: stretchingWall.pointA.x,
                        ay: stretchingWall.pointA.y,
                        bx: stretchingWall.pointB.x,
                        by: stretchingWall.pointB.y
                    };
                    canvas.style.cursor = 'grab';
                } else {
                    // Find wall at click position (only on current floor)
                    // Use containsPoint for normal selection (ignore endpoints for unselected walls)
                    let clickedWall = null;
                    for (let i = walls.length - 1; i >= 0; i--) {
                        if (walls[i].floorId === currentFloorId && walls[i].containsPoint(pos.x, pos.y)) {
                            clickedWall = walls[i];
                            break;
                        }
                    }
                    
                    // Multi-select with shift
                    if (e.shiftKey && clickedWall) {
                        const index = selectedWalls.indexOf(clickedWall);
                        if (index > -1) {
                            // Deselect if already selected
                            selectedWalls.splice(index, 1);
                        } else {
                            // Add to selection
                            selectedWalls.push(clickedWall);
                        }
                    } else if (clickedWall) {
                        // Single select
                        selectedWalls = [clickedWall];
                        
                        // Start dragging
                        isDragging = true;
                        dragStartPos = pos;
                        originalWallPos = {
                            ax: clickedWall.pointA.x,
                            ay: clickedWall.pointA.y,
                            bx: clickedWall.pointB.x,
                            by: clickedWall.pointB.y
                        };
                        canvas.style.cursor = 'grabbing';
                    } else {
                        // Clicked on empty space - clear selection
                        selectedWalls = [];
                    }
                }
                
                updateUI();
                draw();
            } else if (currentMode === 'delete') {
                // Find wall at click position (only on current floor)
                let clickedWall = null;
                for (let i = walls.length - 1; i >= 0; i--) {
                    if (walls[i].floorId === currentFloorId && walls[i].containsPoint(pos.x, pos.y)) {
                        clickedWall = walls[i];
                        break;
                    }
                }
                
                if (clickedWall) {
                    addToHistory();
                    const index = walls.indexOf(clickedWall);
                    if (index > -1) {
                        walls.splice(index, 1);
                        showToast('Deleted 1 wall', 'info', 2000);
                        updateUI();
                        validateAllWalls();
                    }
                }
            }
        });

        // UI Event handlers
        document.getElementById('drawWallBtn').addEventListener('click', () => {
            currentMode = 'draw';
            drawingWall = null;
            tempPoint = null;
            wallFlipped = false;
            selectedWalls = [];
            clearDrawingToast();
            updateModeUI();
            draw();
        });

        document.getElementById('selectBtn').addEventListener('click', () => {
            currentMode = 'select';
            drawingWall = null;
            tempPoint = null;
            wallFlipped = false;
            clearDrawingToast();
            updateModeUI();
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedWalls.length > 0) {
                // Delete all selected walls
                addToHistory();
                const count = selectedWalls.length;
                // Use filter to avoid index shifting issues when deleting multiple walls
                walls = walls.filter(wall => !selectedWalls.includes(wall));
                selectedWalls = [];
                showToast(`Deleted ${count} wall${count > 1 ? 's' : ''}`, 'info', 2000);
                updateUI();
                validateAllWalls();
            } else {
                // Switch to delete mode
                currentMode = 'delete';
                drawingWall = null;
                tempPoint = null;
                wallFlipped = false;
                selectedWalls = [];
                clearDrawingToast();
                updateModeUI();
                draw();
            }
        });
        
        document.getElementById('flipWallBtn').addEventListener('click', () => {
            // Flip wall during drawing
            if (drawingWall && tempPoint) {
                wallFlipped = !wallFlipped;
                draw();
            }
            // Flip selected walls
            else if (selectedWalls.length > 0) {
                addToHistory(); // Save state before flipping
                selectedWalls.forEach(wall => {
                    // Swap pointA and pointB to reverse the wall orientation
                    const tempPoint = wall.pointA;
                    wall.pointA = wall.pointB;
                    wall.pointB = tempPoint;
                    wall.updateVectors(); // Recalculate direction and normal
                });
                validateAllWalls();
                draw();
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Space key to flip wall during drawing or flip selected walls
            if (e.code === 'Space') {
                if (drawingWall && tempPoint) {
                    e.preventDefault(); // Prevent page scroll
                    wallFlipped = !wallFlipped;
                    draw();
                } else if (selectedWalls.length > 0) {
                    e.preventDefault(); // Prevent page scroll
                    addToHistory(); // Save state before flipping
                    selectedWalls.forEach(wall => {
                        // Swap pointA and pointB to reverse the wall orientation
                        const tempPoint = wall.pointA;
                        wall.pointA = wall.pointB;
                        wall.pointB = tempPoint;
                        wall.updateVectors(); // Recalculate direction and normal
                    });
                    validateAllWalls();
                    draw();
                }
            }
            
            // Escape key to cancel wall drawing
            if (e.key === 'Escape' && drawingWall) {
                e.preventDefault();
                drawingWall = null;
                tempPoint = null;
                wallFlipped = false;
                clearDrawingToast();
                draw();
            }
            
            // Ctrl+Z or Cmd+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault(); // Prevent browser undo
                undo();
            }
            
            // Ctrl+Shift+Z or Cmd+Shift+Z or Ctrl+Y for redo
            if ((e.ctrlKey || e.metaKey) && (e.shiftKey && e.key === 'z' || e.key === 'y')) {
                e.preventDefault(); // Prevent browser redo
                redo();
            }
            
            // Delete or Backspace to delete selected walls
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedWalls.length > 0 && currentMode === 'select') {
                e.preventDefault(); // Prevent browser back navigation on Backspace
                addToHistory();
                const count = selectedWalls.length;
                // Use filter to avoid index shifting issues when deleting multiple walls
                walls = walls.filter(wall => !selectedWalls.includes(wall));
                selectedWalls = [];
                updateUI();
                validateAllWalls();
                showToast(`Deleted ${count} wall${count > 1 ? 's' : ''}`, 'info', 2000);
            }
        });

        document.getElementById('clearAllBtn').addEventListener('click', () => {
            if (walls.length > 0 && confirm('Are you sure you want to clear all walls?')) {
                walls = [];
                selectedWalls = [];
                drawingWall = null;
                tempPoint = null;
                history = []; // Clear undo history
                redoHistory = []; // Clear redo history
                updateUI();
                draw();
            }
        });
        
        // Rules Modal
        const rulesModal = document.getElementById('rulesModal');
        const showRulesBtn = document.getElementById('showRulesBtn');
        const modalClose = document.querySelector('.modal-close');
        
        showRulesBtn.addEventListener('click', () => {
            rulesModal.classList.add('show');
        });
        
        modalClose.addEventListener('click', () => {
            rulesModal.classList.remove('show');
        });
        
        // Close modal when clicking outside
        // Changelog Modal
        const changelogModal = document.getElementById('changelogModal');
        const versionBadge = document.getElementById('versionBadge');
        const changelogModalClose = document.getElementById('changelogModalClose');
        
        versionBadge.addEventListener('click', () => {
            changelogModal.classList.add('show');
        });
        
        changelogModalClose.addEventListener('click', () => {
            changelogModal.classList.remove('show');
        });
        
        // Add hover effect to version badge
        versionBadge.addEventListener('mouseenter', () => {
            versionBadge.style.background = 'rgba(0, 0, 0, 0.04)';
            versionBadge.style.borderColor = 'rgba(0, 0, 0, 0.1)';
        });
        
        versionBadge.addEventListener('mouseleave', () => {
            versionBadge.style.background = 'rgba(0, 0, 0, 0.02)';
            versionBadge.style.borderColor = 'rgba(0, 0, 0, 0.06)';
        });
        
        window.addEventListener('click', (e) => {
            if (e.target === rulesModal) {
                rulesModal.classList.remove('show');
            }
            if (e.target === feedbackModal) {
                feedbackModal.classList.remove('show');
            }
            if (e.target === changelogModal) {
                changelogModal.classList.remove('show');
            }
        });
        
        // Feedback Modal
        const feedbackModal = document.getElementById('feedbackModal');
        const feedbackBtn = document.getElementById('feedbackBtn');
        const feedbackModalClose = document.getElementById('feedbackModalClose');
        const feedbackCancel = document.getElementById('feedbackCancel');
        const feedbackForm = document.getElementById('feedbackForm');
        const feedbackStatus = document.getElementById('feedbackStatus');
        
        feedbackBtn.addEventListener('click', () => {
            feedbackModal.classList.add('show');
        });
        
        feedbackModalClose.addEventListener('click', () => {
            feedbackModal.classList.remove('show');
        });
        
        feedbackCancel.addEventListener('click', () => {
            feedbackModal.classList.remove('show');
        });
        
        feedbackForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const submitBtn = document.getElementById('feedbackSubmit');
            const email = document.getElementById('feedbackEmail').value;
            const message = document.getElementById('feedbackMessage').value;
            
            // Disable submit button
            submitBtn.disabled = true;
            submitBtn.textContent = 'Sending...';
            
            try {
                const response = await fetch('/api/feedback', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, message })
                });
                
                if (response.ok) {
                    feedbackStatus.style.display = 'block';
                    feedbackStatus.style.background = 'rgba(76, 175, 80, 0.1)';
                    feedbackStatus.style.color = '#4CAF50';
                    feedbackStatus.textContent = 'Thank you! Your feedback has been sent.';
                    
                    // Reset form
                    feedbackForm.reset();
                    
                    // Close modal after 2 seconds
                    setTimeout(() => {
                        feedbackModal.classList.remove('show');
                        feedbackStatus.style.display = 'none';
                    }, 2000);
                } else {
                    throw new Error('Failed to send feedback');
                }
            } catch (error) {
                feedbackStatus.style.display = 'block';
                feedbackStatus.style.background = 'rgba(244, 67, 54, 0.1)';
                feedbackStatus.style.color = '#f44336';
                feedbackStatus.textContent = 'Oops! Something went wrong. Please try again.';
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Send';
            }
        });

        document.getElementById('showOtherFloors').addEventListener('change', draw);
        document.getElementById('showLevelsAbove').addEventListener('change', draw);

        document.getElementById('wallThickness').addEventListener('change', () => {
            // Update thickness for all selected walls
            if (selectedWalls.length > 0) {
                const newThickness = parseInt(document.getElementById('wallThickness').value);
                selectedWalls.forEach(wall => {
                    wall.thickness = newThickness;
                    wall.updateVectors();
                });
                draw();
                validateAllWalls();
            }
        });
        
        // Level management event listeners
        document.getElementById('addFloorBtn').addEventListener('click', () => {
            const newFloorId = floors.length;
            const newFloor = {
                id: newFloorId,
                name: `Level ${newFloorId + 1}`,
                height: newFloorId * 2700
            };
            floors.push(newFloor);
            updateFloorDropdown();
            currentFloorId = newFloorId;
            document.getElementById('currentFloor').value = currentFloorId;
            draw();
        });
        
        document.getElementById('removeFloorBtn').addEventListener('click', () => {
            if (floors.length > 1) {
                const confirmed = confirm(`Remove ${floors[floors.length - 1].name}? All walls on this level will be deleted.`);
                if (confirmed) {
                    const removedFloorId = floors[floors.length - 1].id;
                    floors.pop();
                    walls = walls.filter(w => w.floorId !== removedFloorId);
                    if (currentFloorId === removedFloorId) {
                        currentFloorId = floors[floors.length - 1].id;
                    }
                    updateFloorDropdown();
                    document.getElementById('currentFloor').value = currentFloorId;
                    draw();
                    validateAllWalls();
                }
            }
        });
        
        document.getElementById('currentFloor').addEventListener('change', (e) => {
            currentFloorId = parseInt(e.target.value);
            selectedWalls = [];
            draw();
            validateAllWalls();
        });
        
        document.getElementById('showOtherFloors').addEventListener('change', draw);
        
        // Initialize UI
        updateFloorDropdown();
        updateModeUI();
        updateUI();
        
        // Show initial message
        document.getElementById('violationsList').innerHTML = 
            '<div class="no-violations">Draw walls to start. Click once for start point, move horizontally or vertically, then click for end point.</div>';
        }

        function updateFloorDropdown() {
            const select = document.getElementById('currentFloor');
            select.innerHTML = '';
            floors.forEach(floor => {
                const option = document.createElement('option');
                option.value = floor.id;
                option.textContent = floor.name;
                select.appendChild(option);
            });
            select.value = currentFloorId;
        }

        function updateModeUI() {
            document.querySelectorAll('.tool-buttons .btn.active').forEach(btn => {
                btn.classList.remove('active');
            });

            if (currentMode === 'draw') {
                document.getElementById('drawWallBtn').classList.add('active');
                canvas.style.cursor = 'crosshair';
            } else if (currentMode === 'select') {
                document.getElementById('selectBtn').classList.add('active');
                canvas.style.cursor = 'pointer';
            } else if (currentMode === 'delete') {
                document.getElementById('deleteBtn').classList.add('active');
                canvas.style.cursor = 'pointer';
            }
        }

        function updateUI() {
            // Update thickness dropdown if there's a single selected wall
            if (selectedWalls.length === 1) {
                document.getElementById('wallThickness').value = selectedWalls[0].thickness;
            }

            draw();
        }
    </script>

    <!-- Rules Modal -->
    <!-- Toast Container -->
    <div id="toast-container"></div>

    <div id="rulesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>
                    <svg width="18" height="18" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: -2px; margin-right: 6px;">
                        <path d="M2 1.5H12C12.5 1.5 13 2 13 2.5V11.5C13 12 12.5 12.5 12 12.5H2C1.5 12.5 1 12 1 11.5V2.5C1 2 1.5 1.5 2 1.5ZM4 4.5H10M4 7H10M4 9.5H8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                    Positional Rules
                </h2>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <p class="modal-intro">The following rules from the original specification are currently implemented in this simulator:</p>
                
                <div class="rule-section">
                    <h3>1. Wall Dimensions</h3>
                    <ul>
                        <li><strong>Minimum Length:</strong> 40 cm</li>
                        <li><strong>Thickness Options:</strong> 20 cm or 30 cm</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>2. Grid Alignment</h3>
                    <ul>
                        <li><strong>Grid Strategy:</strong> 30 cm grid</li>
                        <li><strong>Internal Face (Blue Line):</strong> Must be aligned to the 30 cm grid lines</li>
                        <li><strong>Column Positions:</strong> Columns snap to the 10 cm internal grid at both ends of each wall segment</li>
                        <li><strong>Orientation:</strong> Walls can only be drawn horizontally or vertically</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>3. Same Level Plane Rules</h3>
                    <ul>
                        <li><strong>Overlapping Walls:</strong> Each segment is separate and cannot overlap</li>
                        <li><strong>Aligned Walls:</strong> Walls on the same grid line must share orientation (same direction) and thickness</li>
                        <li><strong>No Overlap:</strong> Aligned walls cannot overlap in their projection along the wall direction</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>4. Different Level Plane Rules</h3>
                    <ul>
                        <li><strong>Vertical Stacking:</strong> Walls on different levels can overlap</li>
                        <li><strong>Matching Required:</strong> Overlapping segments across levels must share orientation and thickness</li>
                        <li><strong>Trace View:</strong> Lower levels are shown with decreasing opacity for reference</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>5. Minimum Distances (Same and Adjacent Levels)</h3>
                    <ul>
                        <li><strong>Parallel Walls (Same Orientation):</strong> Minimum 60 cm distance (measured from blue line to blue line)</li>
                        <li><strong>Parallel Walls (Opposite Orientation, Facing Toward):</strong> Minimum 120 cm distance (measured from blue line to blue line)</li>
                        <li><strong>Parallel Walls (Opposite Orientation, Facing Away):</strong> Minimum 60 cm distance</li>
                        <li><strong>Perpendicular Walls:</strong> No distance restrictions</li>
                        <li><strong>Aligned Walls:</strong> Distance rules do not apply (can be adjacent or have gaps)</li>
                        <li><strong>Cross-Level:</strong> These distance rules apply between consecutive levels (e.g., Level 1 and Level 2)</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>6. Visual Feedback</h3>
                    <ul>
                        <li><strong>Restricted Zones:</strong> Red zones appear when drawing a wall that would violate distance rules</li>
                        <li><strong>Zone Size:</strong> 60 cm or 120 cm depending on wall orientation relationship</li>
                        <li><strong>Cross-Level Zones:</strong> Restriction zones from adjacent levels are also shown</li>
                        <li><strong>Preview Colors:</strong> Green preview indicates valid placement, red preview indicates rule violation</li>
                        <li><strong>Validation:</strong> Real-time validation with detailed error messages</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Feedback Modal -->
    <div id="feedbackModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>
                    <svg width="18" height="18" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: -2px; margin-right: 6px;">
                        <path d="M7 13C10.3137 13 13 10.3137 13 7C13 3.68629 10.3137 1 7 1C3.68629 1 1 3.68629 1 7C1 8.5 1.5 9.8 2.5 10.8L1.5 13L4 12C5 12.6 6 13 7 13Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Send Feedback
                </h2>
                <span class="modal-close" id="feedbackModalClose">&times;</span>
            </div>
            <div class="modal-body">
                <p class="modal-intro">Help us improve! Share your thoughts, report bugs, or request features.</p>
                
                <form id="feedbackForm" style="margin-top: 24px;">
                    <div class="property-group">
                        <label for="feedbackEmail" style="display: block; margin-bottom: 6px; font-weight: 500; color: #2a2a2a;">Email (optional)</label>
                        <input type="email" id="feedbackEmail" placeholder="your@email.com" style="width: 100%; padding: 10px 12px; border: 1px solid #e0e0e0; border-radius: 8px; font-size: 14px; font-family: 'Inter', sans-serif;">
                    </div>
                    
                    <div class="property-group" style="margin-top: 16px;">
                        <label for="feedbackMessage" style="display: block; margin-bottom: 6px; font-weight: 500; color: #2a2a2a;">Message</label>
                        <textarea id="feedbackMessage" required placeholder="Tell us what you think..." rows="6" style="width: 100%; padding: 10px 12px; border: 1px solid #e0e0e0; border-radius: 8px; font-size: 14px; font-family: 'Inter', sans-serif; resize: vertical;"></textarea>
                    </div>
                    
                    <div style="display: flex; gap: 12px; margin-top: 24px; justify-content: flex-end;">
                        <button type="button" id="feedbackCancel" class="btn btn-secondary">Cancel</button>
                        <button type="submit" id="feedbackSubmit" class="btn btn-secondary" style="background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%); color: #ffffff; border-color: #1a1a1a;">Send</button>
                    </div>
                </form>
                
                <div id="feedbackStatus" style="display: none; margin-top: 16px; padding: 12px; border-radius: 8px; text-align: center;"></div>
            </div>
        </div>
    </div>

    <!-- Changelog Modal -->
    <div id="changelogModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>
                    <svg width="18" height="18" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: -2px; margin-right: 6px;">
                        <path d="M7 1V13M7 1L4 4M7 1L10 4M7 13L4 10M7 13L10 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Changelog — Version 1.1.0
                </h2>
                <span class="modal-close" id="changelogModalClose">&times;</span>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <p class="modal-intro">All notable changes and features in this release.</p>
                
                <div class="rule-section">
                    <h3>✨ Added</h3>
                    <ul>
                        <li><strong>Wall stretching:</strong> Click and drag wall endpoints to resize walls, constrained to gridlines with real-time validation</li>
                        <li><strong>Multi-level simulation:</strong> Create and manage multiple building levels with independent wall placement</li>
                        <li><strong>Level visualization:</strong>
                            <ul style="margin-top: 8px;">
                                <li>"Show Levels Below" to ghost walls from lower levels with increasing transparency</li>
                                <li>"Show Levels Above" to show dashed outlines with faint grey fill for upper level walls</li>
                            </ul>
                        </li>
                        <li><strong>Interactive wall drawing:</strong> Draw walls on a 30cm grid with real-time preview, grid snapping, thickness options (20cm/30cm), minimum length 40cm</li>
                        <li><strong>Wall flipping:</strong> Flip wall orientation during drawing (Space key) or after placement (select + Space)</li>
                        <li><strong>Selection and manipulation:</strong> Select single/multiple walls (Shift+click), move with drag-and-drop, delete via Delete/Backspace</li>
                        <li><strong>Undo/Redo system:</strong> Ctrl/Cmd+Z to undo, Ctrl/Cmd+Shift+Z or Ctrl/Cmd+Y to redo — supports all operations</li>
                        <li><strong>Canvas navigation:</strong> Pan with click and drag, zoom with scroll wheel, grid adjusts to viewport</li>
                        <li><strong>Real-time validation:</strong> Dynamic restriction zones, red pulsing on conflicting walls, green/red preview, toast notifications</li>
                        <li><strong>Positional rules modal:</strong> View complete list of enforced rules</li>
                        <li><strong>Feedback system:</strong> Send feedback directly from the app</li>
                        <li><strong>Apple-style UI:</strong> Minimal design, custom SVG icons, smooth animations, professional typography</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>📏 Rules Enforced</h3>
                    <ul>
                        <li><strong>Same-floor aligned walls:</strong> Must share orientation and thickness; cannot overlap</li>
                        <li><strong>Cross-floor aligned walls:</strong> Can be placed on same gridline with matching orientation/thickness</li>
                        <li><strong>Cross-floor overlapping walls:</strong> Must share orientation and thickness</li>
                        <li><strong>Parallel wall distances:</strong>
                            <ul style="margin-top: 8px;">
                                <li>Same orientation: Minimum 60cm (column face to column face)</li>
                                <li>Opposite orientation facing each other: Minimum 120cm</li>
                                <li>Opposite orientation facing away: Minimum 60cm</li>
                                <li>Applies to both same-floor and consecutive levels</li>
                            </ul>
                        </li>
                        <li><strong>Perpendicular walls:</strong> No restrictions</li>
                        <li><strong>Column placement:</strong> 10cm × 10cm columns at both ends of each wall, aligned to internal corner</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <h3>🔧 Technical</h3>
                    <ul>
                        <li>Single-file HTML application with embedded CSS and JavaScript</li>
                        <li>Canvas-based rendering with transformation matrix for pan/zoom</li>
                        <li>Grid system: 30cm major grid with 10cm subdivisions</li>
                        <li>Wall model: Internal face (blue line) grid-aligned, external face calculated</li>
                        <li>Cross-floor validation with body overlap detection</li>
                        <li>Floating-point tolerance (2mm) for distance comparisons</li>
                        <li>History stack with 50-operation limit</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

<!-- Cache buster: 1761842634 -->
