<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symmetry Line Simulator - 300mm Grid Strategy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #2196F3;
            color: white;
        }

        .sidebar-header h1 {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 12px;
            opacity: 0.9;
        }

        .tools-section {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #2196F3;
            color: white;
        }

        .btn-primary:hover {
            background: #1976D2;
        }

        .btn-primary.active {
            background: #1565C0;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 6px;
            color: #555;
        }

        .property-group select,
        .property-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .property-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #555;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .toolbar {
            background: white;
            border-bottom: 1px solid #e0e0e0;
            padding: 15px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        canvas {
            cursor: crosshair;
            display: block;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 13px;
            min-width: 200px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .info-label {
            color: #666;
            margin-right: 15px;
        }

        .info-value {
            font-weight: 600;
            color: #333;
        }

        .violations-panel {
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .violation-item {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-size: 13px;
        }

        .violation-item.error {
            background: #ffebee;
            border-left-color: #f44336;
        }

        .violation-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #d84315;
        }

        .violation-item.error .violation-title {
            color: #c62828;
        }

        .no-violations {
            text-align: center;
            padding: 20px;
            color: #4caf50;
            font-weight: 500;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 13px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-label {
            color: #666;
        }

        .stat-value {
            font-weight: 600;
            color: #2196F3;
        }

        .help-text {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>Symmetry Line Simulator</h1>
        </div>

        <div class="tools-section">
            <div class="section-title">Tools</div>
            <div class="tool-buttons">
                <button id="drawWallBtn" class="btn btn-primary">
                    ‚úèÔ∏è Draw Wall
                </button>
                <button id="selectBtn" class="btn btn-secondary">
                    üëÜ Select / Move
                </button>
                <button id="deleteBtn" class="btn btn-danger">
                    üóëÔ∏è Delete Selected
                </button>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Floor Management</div>
            <div class="property-group">
                <label for="currentFloor">Current Floor</label>
                <select id="currentFloor">
                    <option value="0">Ground Floor</option>
                </select>
            </div>
            <div class="tool-buttons">
                <button id="addFloorBtn" class="btn btn-secondary">
                    ‚ûï Add Floor Above
                </button>
                <button id="removeFloorBtn" class="btn btn-secondary">
                    ‚ûñ Remove Current Floor
                </button>
            </div>
            <div class="property-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showOtherFloors" checked>
                    Show Adjacent Floors
                </label>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Wall Properties</div>
            <div class="property-group">
                <label for="wallThickness">Thickness (mm)</label>
                <select id="wallThickness">
                    <option value="200">200 mm</option>
                    <option value="300">300 mm</option>
                </select>
            </div>
            <div class="property-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showGrid" checked>
                    Show Grid
                </label>
            </div>
            <div class="property-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showRestrictedZones" checked>
                    Show Restricted Zones
                </label>
            </div>
        </div>

        <div class="tools-section">
            <div class="section-title">Actions</div>
            <div class="tool-buttons">
                <button id="clearAllBtn" class="btn btn-secondary">
                    üîÑ Clear All
                </button>
            </div>
        </div>

        <div class="violations-panel">
            <div class="section-title">Validation Results</div>
            <div id="violationsList">
                <div class="no-violations">No walls drawn yet</div>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="toolbar">
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Walls:</span>
                    <span class="stat-value" id="wallCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Selected:</span>
                    <span class="stat-value" id="selectedInfo">None</span>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <script>
        // Constants
        const GRID_SIZE_EXTERNAL = 300; // mm - 300mm grid external
        const GRID_SIZE_INTERNAL = 100; // mm - 100mm internal
        const MM_TO_PX = 0.15; // Scale factor for visualization (1mm = 0.15px)
        const COLUMN_SIZE = 100; // mm - 10x10cm steel column
        const MIN_WALL_LENGTH = 400; // mm
        const MAX_WALL_LENGTH = 6000; // mm
        const MIN_DISTANCE_PARALLEL = 600; // mm
        const MIN_DISTANCE_OPPOSITE = 1200; // mm

        // State
        let walls = [];
        let selectedWall = null;
        let currentMode = 'draw';
        let drawingWall = null;
        let tempPoint = null;
        
        // Floor management
        let floors = [
            { id: 0, name: 'Ground Floor', height: 0 }
        ];
        let currentFloorId = 0;

        // Canvas variables
        let canvas, ctx;
        
        // Initialize everything when DOM is ready
        window.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            
            canvas = document.getElementById('mainCanvas');
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            ctx = canvas.getContext('2d');
            console.log('Canvas and context initialized');
            
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                if (canvas.width > 0 && canvas.height > 0) {
                    draw();
                } else {
                    console.error('Canvas has zero dimensions!');
                }
            }
            
            window.addEventListener('resize', resizeCanvas);
            
            // Give the browser time to layout the DOM
            setTimeout(() => {
                resizeCanvas();
                setupEventListeners();
            }, 100);
        });

        // Wall class
        class Wall {
            constructor(ax, ay, bx, by, thickness = 200, height = 2700, groupId = null, floorId = 0) {
                // Points A and B ARE on the INTERNAL face (blue line - grid-aligned with columns)
                // The user draws on the grid lines, which become the internal face
                this.pointA = { x: ax, y: ay }; // Internal face point A (blue line, grid-aligned)
                this.pointB = { x: bx, y: by }; // Internal face point B (blue line, grid-aligned)
                this.thickness = thickness; // mm
                this.height = height; // mm
                this.groupId = groupId; // For tracking segments of the same wall
                this.floorId = floorId; // Which floor this wall belongs to
                this.updateVectors();
            }

            updateVectors() {
                // Direction vector d = AB
                this.d = {
                    x: this.pointB.x - this.pointA.x,
                    y: this.pointB.y - this.pointA.y
                };

                // Length
                this.length = Math.sqrt(this.d.x * this.d.x + this.d.y * this.d.y);

                // Normalized direction (handle zero-length case)
                if (this.length > 0) {
                    this.dNorm = {
                        x: this.d.x / this.length,
                        y: this.d.y / this.length
                    };
                } else {
                    // Default to horizontal for zero-length walls
                    this.dNorm = { x: 1, y: 0 };
                }

                // Normal vector n (perpendicular, pointing INWARD from external face)
                // Right-hand cross product: up √ó d
                this.n = {
                    x: -this.dNorm.y,
                    y: this.dNorm.x
                };
            }

            getExternalFacePoints() {
                // External face is thickness distance outward from internal face (A and B)
                return {
                    a: {
                        x: this.pointA.x + this.n.x * this.thickness,
                        y: this.pointA.y + this.n.y * this.thickness
                    },
                    b: {
                        x: this.pointB.x + this.n.x * this.thickness,
                        y: this.pointB.y + this.n.y * this.thickness
                    }
                };
            }

            getInternalFacePoints() {
                // Internal face IS points A and B (for backward compatibility)
                return {
                    a: this.pointA,
                    b: this.pointB
                };
            }

            isParallelTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot > 0.999; // Almost parallel
            }

            isPerpendicularTo(other) {
                const dot = Math.abs(this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y);
                return dot < 0.1; // Almost perpendicular
            }

            sameOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot > 0.9;
            }

            oppositeOrientation(other) {
                const dot = this.dNorm.x * other.dNorm.x + this.dNorm.y * other.dNorm.y;
                return dot < -0.9;
            }

            overlapsInProjection(other) {
                // Project both walls onto the line direction
                const dir = this.dNorm;
                
                const a1 = this.pointA.x * dir.x + this.pointA.y * dir.y;
                const b1 = this.pointB.x * dir.x + this.pointB.y * dir.y;
                const min1 = Math.min(a1, b1);
                const max1 = Math.max(a1, b1);

                const a2 = other.pointA.x * dir.x + other.pointA.y * dir.y;
                const b2 = other.pointB.x * dir.x + other.pointB.y * dir.y;
                const min2 = Math.min(a2, b2);
                const max2 = Math.max(a2, b2);

                // Allow touching at endpoints (use <= to exclude touching walls)
                // Add small tolerance for floating point comparisons
                const tolerance = 1; // 1mm tolerance
                return !(max1 <= min2 + tolerance || max2 <= min1 + tolerance);
            }

            distanceToWall(other) {
                // Calculate minimum distance between INTERNAL faces (blue lines - column face to column face)
                const internal1 = this.getInternalFacePoints();
                const internal2 = other.getInternalFacePoints();

                // Distance between the two internal faces (blue lines)
                const distances = [
                    this.pointToLineDistance(internal1.a, internal2.a, internal2.b),
                    this.pointToLineDistance(internal1.b, internal2.a, internal2.b),
                    this.pointToLineDistance(internal2.a, internal1.a, internal1.b),
                    this.pointToLineDistance(internal2.b, internal1.a, internal1.b)
                ];

                return Math.min(...distances);
            }

            pointToLineDistance(point, lineA, lineB) {
                const dx = lineB.x - lineA.x;
                const dy = lineB.y - lineA.y;
                const lenSq = dx * dx + dy * dy;
                
                if (lenSq === 0) return Math.sqrt(
                    (point.x - lineA.x) ** 2 + (point.y - lineA.y) ** 2
                );

                let t = ((point.x - lineA.x) * dx + (point.y - lineA.y) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));

                const projX = lineA.x + t * dx;
                const projY = lineA.y + t * dy;

                return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);
            }

            containsPoint(x, y, tolerance = 10) {
                const internal = this.getInternalFacePoints();
                
                // Check if point is within the wall rectangle (with tolerance)
                const dx = this.pointB.x - this.pointA.x;
                const dy = this.pointB.y - this.pointA.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = -dy / len;
                const ny = dx / len;

                // Create wall rectangle vertices
                const vertices = [
                    this.pointA,
                    this.pointB,
                    internal.b,
                    internal.a
                ];

                return this.isPointInPolygon({ x, y }, vertices, tolerance);
            }

            isPointInPolygon(point, vertices, tolerance) {
                let inside = false;
                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;
                    
                    const intersect = ((yi > point.y) !== (yj > point.y))
                        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                
                // Also check distance to edges
                for (let i = 0; i < vertices.length; i++) {
                    const j = (i + 1) % vertices.length;
                    const dist = this.pointToLineDistance(point, vertices[i], vertices[j]);
                    if (dist < tolerance) return true;
                }
                
                return inside;
            }
        }

        // Grid snapping - snap to 300mm external grid only
        function snapToGrid(value, gridSize = GRID_SIZE_EXTERNAL) {
            return Math.round(value / gridSize) * gridSize;
        }

        function mmToPx(mm) {
            return mm * MM_TO_PX;
        }

        function pxToMm(px) {
            return px / MM_TO_PX;
        }

        function pxSnapToGrid(px, gridSize = GRID_SIZE_EXTERNAL) {
            const mm = pxToMm(px);
            const snappedMm = snapToGrid(mm, gridSize);
            return mmToPx(snappedMm);
        }

        // Drawing functions
        function drawGrid() {
            if (!ctx || !canvas) {
                console.error('Canvas not initialized in drawGrid!');
                return;
            }
            
            const showGridCheckbox = document.getElementById('showGrid');
            if (showGridCheckbox && !showGridCheckbox.checked) return;
            
            console.log('Drawing grid...');
            const gridStepExternal = mmToPx(GRID_SIZE_EXTERNAL);
            const gridStepInternal = mmToPx(GRID_SIZE_INTERNAL);
            console.log('Grid steps:', gridStepExternal, gridStepInternal);

            // Draw 300mm grid (external) - DARK, thicker lines
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2;
            for (let x = 0; x <= canvas.width; x += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridStepExternal) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw 100mm grid (internal) - lighter lines
            ctx.strokeStyle = '#dddddd';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= canvas.width; x += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(x % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridStepInternal) {
                // Skip if it's on a 300mm line
                if (Math.abs(y % gridStepExternal) < 0.5) continue;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function getRestrictedZones(wall) {
            // Show restricted zones from all floors on the current floor
            const zones = [];
            // Internal face is at points A and B (blue line)
            const internalY = wall.pointA.y;
            const internalX = wall.pointA.x;

            // Determine if wall is horizontal or vertical
            const isHorizontal = Math.abs(wall.d.y) < Math.abs(wall.d.x);

            // Use canvas dimensions to make zones "infinite"
            const canvasMaxX = pxToMm(canvas.width);
            const canvasMaxY = pxToMm(canvas.height);

            if (isHorizontal) {
                // Horizontal wall - restricted zones extend infinitely along X
                // Internal face is at A-B (y coordinate)

                // Zone away from internal face (opposite side - toward external face direction)
                const oppositeY = internalY + (wall.n.y > 0 ? MIN_DISTANCE_OPPOSITE : -MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: 0,
                    y1: Math.min(internalY, oppositeY),
                    x2: canvasMaxX,
                    y2: Math.max(internalY, oppositeY),
                    distance: MIN_DISTANCE_OPPOSITE
                });

                // Zone toward internal face (same side)
                const parallelY = internalY + (wall.n.y > 0 ? -MIN_DISTANCE_PARALLEL : MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: 0,
                    y1: Math.min(internalY, parallelY),
                    x2: canvasMaxX,
                    y2: Math.max(internalY, parallelY),
                    distance: MIN_DISTANCE_PARALLEL
                });
            } else {
                // Vertical wall - restricted zones extend infinitely along Y
                // Internal face is at A-B (x coordinate)

                // Zone away from internal face (opposite side - toward external face direction)
                const oppositeX = internalX + (wall.n.x > 0 ? MIN_DISTANCE_OPPOSITE : -MIN_DISTANCE_OPPOSITE);
                zones.push({
                    type: 'opposite',
                    x1: Math.min(internalX, oppositeX),
                    y1: 0,
                    x2: Math.max(internalX, oppositeX),
                    y2: canvasMaxY,
                    distance: MIN_DISTANCE_OPPOSITE
                });

                // Zone toward internal face (same side)
                const parallelX = internalX + (wall.n.x > 0 ? -MIN_DISTANCE_PARALLEL : MIN_DISTANCE_PARALLEL);
                zones.push({
                    type: 'parallel',
                    x1: Math.min(internalX, parallelX),
                    y1: 0,
                    x2: Math.max(internalX, parallelX),
                    y2: canvasMaxY,
                    distance: MIN_DISTANCE_PARALLEL
                });
            }

            return zones;
        }

        function drawRestrictedZones() {
            if (!document.getElementById('showRestrictedZones').checked) return;
            
            walls.forEach(wall => {
                const zones = getRestrictedZones(wall);
                
                zones.forEach(zone => {
                    ctx.fillStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.1)' :  // Red for opposite (1200mm)
                        'rgba(255, 152, 0, 0.08)';   // Orange for parallel (600mm)
                    
                    ctx.fillRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );

                    // Draw border
                    ctx.strokeStyle = zone.type === 'opposite' ? 
                        'rgba(244, 67, 54, 0.3)' : 
                        'rgba(255, 152, 0, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.strokeRect(
                        mmToPx(zone.x1),
                        mmToPx(zone.y1),
                        mmToPx(zone.x2 - zone.x1),
                        mmToPx(zone.y2 - zone.y1)
                    );
                    ctx.setLineDash([]);
                });
            });
        }

        function isWallInRestrictedZone(newWall) {
            for (let existingWall of walls) {
                const onSameFloor = newWall.floorId === existingWall.floorId;
                const onDifferentFloor = newWall.floorId !== existingWall.floorId;
                
                // Check if walls are perpendicular - no restriction
                if (existingWall.isPerpendicularTo(newWall)) {
                    continue;
                }

                // Check if parallel
                if (existingWall.isParallelTo(newWall)) {
                    const dist = newWall.distanceToWall(existingWall);
                    
                    // Aligned walls (on same line)
                    if (dist < 10) {
                        // Rule 1 (same floor): Aligned walls allowed if same orientation/thickness and no overlap
                        // Rule 2 (different floors): Overlapping allowed if same orientation/thickness
                        // So aligned walls are never a restriction if they meet the criteria
                        continue;
                    }
                    
                    // Non-aligned parallel walls on same floor need minimum distance (Rule 3a)
                    if (onSameFloor) {
                        // Use dot product to determine minimum distance
                        const dotProduct = newWall.n.x * existingWall.n.x + newWall.n.y * existingWall.n.y;
                        
                        let minDist;
                        if (dotProduct >= 0) {
                            // Same side: 600mm
                            minDist = MIN_DISTANCE_PARALLEL;
                        } else {
                            // Flipped - check if anti-parallel
                            if (dotProduct < -0.9) {
                                // Anti-parallel (opposite facing): 1200mm
                                minDist = MIN_DISTANCE_OPPOSITE;
                            } else {
                                // Parallel but not anti-parallel: 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            }
                        }

                        if (dist < minDist) {
                            return { 
                                restricted: true, 
                                wall: existingWall, 
                                zone: { distance: minDist }
                            };
                        }
                    }
                    // Different floors: no distance restriction (Rule 2 allows overlapping)
                }
            }
            return { restricted: false };
        }

        function drawWall(wall, isSelected = false, violations = [], opacity = 1.0, overrideColor = null) {
            const hasViolation = violations.length > 0;
            const external = wall.getExternalFacePoints();
            
            // Apply opacity for adjacent floor walls
            ctx.globalAlpha = opacity;

            // Draw wall body (from internal face A-B to external face)
            if (overrideColor) {
                ctx.fillStyle = overrideColor.replace(')', ', 0.15)').replace('rgb', 'rgba');
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? 'rgba(244, 67, 54, 0.2)' : 
                               isSelected ? 'rgba(33, 150, 243, 0.3)' : 'rgba(158, 158, 158, 0.3)';
                ctx.strokeStyle = hasViolation ? '#f44336' :
                                 isSelected ? '#2196F3' : '#757575';
            }
            ctx.lineWidth = isSelected ? 3 : 2;

            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw INTERNAL face line (BLUE - grid-aligned side with columns)
            // This is at points A and B
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = '#2196F3';
            }
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(mmToPx(wall.pointA.x), mmToPx(wall.pointA.y));
            ctx.lineTo(mmToPx(wall.pointB.x), mmToPx(wall.pointB.y));
            ctx.stroke();

            // Draw external face line (thinner, darker)
            if (overrideColor) {
                ctx.strokeStyle = overrideColor;
            } else {
                ctx.strokeStyle = hasViolation ? '#d32f2f' :
                                 isSelected ? '#1976D2' : '#424242';
            }
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.beginPath();
            ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
            ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
            ctx.stroke();

            // Draw steel columns (10x10cm squares at A and B on the BLUE LINE)
            const columnSize = mmToPx(COLUMN_SIZE);
            if (overrideColor) {
                ctx.fillStyle = overrideColor;
            } else {
                ctx.fillStyle = hasViolation ? '#f44336' :
                               isSelected ? '#2196F3' : '#616161';
            }

            // Column at A (on internal face - blue line)
            // Position column in grid cell, aligned to internal corner
            // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
            const colAX = wall.pointA.x + (COLUMN_SIZE / 2) * wall.dNorm.x + (COLUMN_SIZE / 2) * wall.n.x;
            const colAY = wall.pointA.y + (COLUMN_SIZE / 2) * wall.dNorm.y + (COLUMN_SIZE / 2) * wall.n.y;
            ctx.fillRect(
                mmToPx(colAX) - columnSize / 2,
                mmToPx(colAY) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Column at B (on internal face - blue line)
            // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
            const colBX = wall.pointB.x - (COLUMN_SIZE / 2) * wall.dNorm.x + (COLUMN_SIZE / 2) * wall.n.x;
            const colBY = wall.pointB.y - (COLUMN_SIZE / 2) * wall.dNorm.y + (COLUMN_SIZE / 2) * wall.n.y;
            ctx.fillRect(
                mmToPx(colBX) - columnSize / 2,
                mmToPx(colBY) - columnSize / 2,
                columnSize,
                columnSize
            );

            // Draw dimensions
            if (isSelected) {
                const midX = (wall.pointA.x + wall.pointB.x) / 2;
                const midY = (wall.pointA.y + wall.pointB.y) / 2;
                
                ctx.fillStyle = '#2196F3';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `${Math.round(wall.length)}mm (${wall.thickness}mm thick)`,
                    mmToPx(midX),
                    mmToPx(midY) - 15
                );
            }
            
            // Reset global alpha
            ctx.globalAlpha = 1.0;
        }

        function draw() {
            console.log('draw() called');
            
            if (!ctx || !canvas) {
                console.error('Canvas not initialized in draw!');
                return;
            }
            
            console.log('Drawing on canvas:', canvas.width, 'x', canvas.height);
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();

            // Draw walls from adjacent floors first (if enabled)
            if (document.getElementById('showOtherFloors').checked) {
                walls.forEach((wall, idx) => {
                    // Draw walls from floor below
                    if (wall.floorId === currentFloorId - 1) {
                        drawWall(wall, false, [], 0.3, '#90A4AE'); // Light gray, semi-transparent
                    }
                    // Draw walls from floor above
                    else if (wall.floorId === currentFloorId + 1) {
                        drawWall(wall, false, [], 0.2, '#B0BEC5'); // Lighter gray, more transparent
                    }
                });
            }

            // Get current floor walls
            const currentFloorWalls = walls.filter(w => w.floorId === currentFloorId);

            // Draw restricted zones from all floors
            if (walls.length > 0) {
                drawRestrictedZones();
            }

            // Get violations for current floor walls
            const wallViolations = new Map();
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId || 
                    wall.floorId === currentFloorId - 1 || 
                    wall.floorId === currentFloorId + 1) {
                    wallViolations.set(idx, validateWall(wall, idx));
                }
            });

            // Draw current floor walls
            walls.forEach((wall, idx) => {
                if (wall.floorId === currentFloorId) {
                    const isSelected = wall === selectedWall;
                    const violations = wallViolations.get(idx) || [];
                    drawWall(wall, isSelected, violations);
                }
            });

            // Draw temporary wall while drawing
            if (drawingWall && tempPoint && (drawingWall.x !== tempPoint.x || drawingWall.y !== tempPoint.y)) {
                const tempWall = new Wall(
                    drawingWall.x,
                    drawingWall.y,
                    tempPoint.x,
                    tempPoint.y,
                    parseInt(document.getElementById('wallThickness').value),
                    2700 // Default height
                );
                
                // Calculate wall segments if longer than MAX_WALL_LENGTH
                const wallSegments = [];
                if (tempWall.length > MAX_WALL_LENGTH) {
                    const numSegments = Math.ceil(tempWall.length / MAX_WALL_LENGTH);
                    const groupId = Date.now() + Math.random(); // Unique ID for preview segments
                    
                    for (let i = 0; i < numSegments; i++) {
                        const startRatio = i / numSegments;
                        const endRatio = (i + 1) / numSegments;
                        
                        let segStart = {
                            x: drawingWall.x + tempWall.d.x * startRatio,
                            y: drawingWall.y + tempWall.d.y * startRatio
                        };
                        let segEnd = {
                            x: drawingWall.x + tempWall.d.x * endRatio,
                            y: drawingWall.y + tempWall.d.y * endRatio
                        };
                        
                        // Snap junction points to 100mm grid (columns must be on grid)
                        // First and last points are already snapped (from user drawing)
                        if (i > 0) {
                            segStart.x = snapToGrid(segStart.x, GRID_SIZE_INTERNAL);
                            segStart.y = snapToGrid(segStart.y, GRID_SIZE_INTERNAL);
                        }
                        if (i < numSegments - 1) {
                            segEnd.x = snapToGrid(segEnd.x, GRID_SIZE_INTERNAL);
                            segEnd.y = snapToGrid(segEnd.y, GRID_SIZE_INTERNAL);
                        }
                        
                        wallSegments.push(new Wall(
                            segStart.x, segStart.y,
                            segEnd.x, segEnd.y,
                            tempWall.thickness,
                            tempWall.height,
                            groupId, // Assign the same groupId to all preview segments
                            currentFloorId // Preview on current floor
                        ));
                    }
                } else {
                    wallSegments.push(tempWall);
                }
                
                // Check if any segment is in restricted zone
                let isRestricted = false;
                let restriction = { restricted: false };
                for (let segment of wallSegments) {
                    const segRestriction = isWallInRestrictedZone(segment);
                    if (segRestriction.restricted) {
                        isRestricted = true;
                        restriction = segRestriction;
                        break;
                    }
                }
                
                // Draw each segment
                wallSegments.forEach((segment, idx) => {
                    const external = segment.getExternalFacePoints();
                
                    // Draw full wall preview (semi-transparent)
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.2)' : 'rgba(76, 175, 80, 0.2)';
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.lineTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Draw INTERNAL face (BLUE - grid-aligned side with columns)
                    // This is at points A and B (the grid line)
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(segment.pointA.x), mmToPx(segment.pointA.y));
                    ctx.lineTo(mmToPx(segment.pointB.x), mmToPx(segment.pointB.y));
                    ctx.stroke();

                    // Draw external face (dashed)
                    ctx.strokeStyle = isRestricted ? '#f44336' : '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(mmToPx(external.a.x), mmToPx(external.a.y));
                    ctx.lineTo(mmToPx(external.b.x), mmToPx(external.b.y));
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw steel column previews at A and B (on the BLUE LINE)
                    const columnSize = mmToPx(COLUMN_SIZE);
                    ctx.fillStyle = isRestricted ? 'rgba(244, 67, 54, 0.5)' : 'rgba(76, 175, 80, 0.5)';
                    
                    // Column at A (on internal face - blue line)
                    // Position column in grid cell, aligned to internal corner
                    // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
                    const colAX = segment.pointA.x + (COLUMN_SIZE / 2) * segment.dNorm.x + (COLUMN_SIZE / 2) * segment.n.x;
                    const colAY = segment.pointA.y + (COLUMN_SIZE / 2) * segment.dNorm.y + (COLUMN_SIZE / 2) * segment.n.y;
                    ctx.fillRect(
                        mmToPx(colAX) - columnSize / 2,
                        mmToPx(colAY) - columnSize / 2,
                        columnSize,
                        columnSize
                    );
                    
                    // Column at B (on internal face - blue line)
                    // Offset along wall direction (inward by 50mm) and perpendicular (inward by 50mm)
                    const colBX = segment.pointB.x - (COLUMN_SIZE / 2) * segment.dNorm.x + (COLUMN_SIZE / 2) * segment.n.x;
                    const colBY = segment.pointB.y - (COLUMN_SIZE / 2) * segment.dNorm.y + (COLUMN_SIZE / 2) * segment.n.y;
                    ctx.fillRect(
                        mmToPx(colBX) - columnSize / 2,
                        mmToPx(colBY) - columnSize / 2,
                        columnSize,
                        columnSize
                    );

                    // Draw segment split markers if multiple segments
                    if (wallSegments.length > 1 && idx < wallSegments.length - 1) {
                        ctx.strokeStyle = '#FF9800';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([]);
                        const splitX = segment.pointB.x;
                        const splitY = segment.pointB.y;
                        
                        // Draw a small perpendicular line at the split
                        const perpLen = 20;
                        const perpX = -segment.dNorm.y * perpLen;
                        const perpY = segment.dNorm.x * perpLen;
                        
                        ctx.beginPath();
                        ctx.moveTo(mmToPx(splitX - perpX), mmToPx(splitY - perpY));
                        ctx.lineTo(mmToPx(splitX + perpX), mmToPx(splitY + perpY));
                        ctx.stroke();
                    }
                });

                // Draw start and end points
                ctx.fillStyle = isRestricted ? '#f44336' : '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(mmToPx(tempPoint.x), mmToPx(tempPoint.y), 6, 0, Math.PI * 2);
                ctx.fill();

                // Show info text
                const midX = (drawingWall.x + tempPoint.x) / 2;
                const midY = (drawingWall.y + tempPoint.y) / 2;
                
                ctx.fillStyle = isRestricted ? '#f44336' : '#4CAF50';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                
                if (isRestricted) {
                    ctx.fillText(
                        '‚úó Cannot place here',
                        mmToPx(midX),
                        mmToPx(midY) - 10
                    );
                    ctx.font = '12px sans-serif';
                    ctx.fillText(
                        `Min distance: ${restriction.zone.distance}mm`,
                        mmToPx(midX),
                        mmToPx(midY) + 10
                    );
                } else {
                    const totalLength = Math.round(tempWall.length);
                    if (wallSegments.length > 1) {
                        ctx.fillText(
                            `${totalLength}mm (${wallSegments.length} walls)`,
                            mmToPx(midX),
                            mmToPx(midY) - 10
                        );
                    } else {
                        ctx.fillText(
                            `${totalLength}mm`,
                            mmToPx(midX),
                            mmToPx(midY) - 10
                        );
                    }
                }
            }

            // Show starting point when first click is placed but no preview yet
            if (drawingWall && (!tempPoint || (drawingWall.x === tempPoint.x && drawingWall.y === tempPoint.y))) {
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw pulsing ring
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mmToPx(drawingWall.x), mmToPx(drawingWall.y), 12, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Show snap indicator when hovering and ready to start drawing
            if (currentMousePos && currentMode === 'draw' && !drawingWall) {
                drawSnapIndicator(currentMousePos.x, currentMousePos.y);
            }
        }

        // Validation functions
        function validateWall(wall, wallIndex) {
            const violations = [];

            // Check length
            if (wall.length < MIN_WALL_LENGTH) {
                violations.push({
                    type: 'error',
                    message: `Wall is too short (${Math.round(wall.length)}mm). Minimum: ${MIN_WALL_LENGTH}mm`
                });
            }

            if (wall.length > MAX_WALL_LENGTH) {
                violations.push({
                    type: 'error',
                    message: `Wall is too long (${Math.round(wall.length)}mm). Maximum: ${MAX_WALL_LENGTH}mm`
                });
            }

            // Check against other walls
            walls.forEach((otherWall, otherIndex) => {
                if (wallIndex === otherIndex) return;
                
                // Skip validation between segments of the same wall (auto-split)
                if (wall.groupId && wall.groupId === otherWall.groupId) return;
                
                // Determine if walls are on same floor or adjacent floors
                const onSameFloor = wall.floorId === otherWall.floorId;
                const onAdjacentFloors = Math.abs(wall.floorId - otherWall.floorId) === 1;

                // SAME FLOOR RULES (Rule 1 & 3)
                if (onSameFloor) {
                    // Check if walls are parallel
                    if (wall.isParallelTo(otherWall)) {
                        const dist = wall.distanceToWall(otherWall);
                        
                        if (dist < 10) { // Aligned (on same line)
                            // Rule 1: Aligned walls cannot overlap and must share orientation and thickness
                            if (wall.overlapsInProjection(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls overlap with Wall ${otherIndex + 1}`
                                });
                            }

                            if (!wall.sameOrientation(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share orientation with Wall ${otherIndex + 1}`
                                });
                            }

                            if (wall.thickness !== otherWall.thickness) {
                                violations.push({
                                    type: 'error',
                                    message: `Aligned walls must share thickness with Wall ${otherIndex + 1}`
                                });
                            }
                        } else {
                            // Rule 3a: Parallel walls minimum distance
                            // Use dot product to determine orientation relationship
                            const dotProduct = wall.n.x * otherWall.n.x + wall.n.y * otherWall.n.y;
                            
                            let minDist;
                            if (dotProduct >= 0) {
                                // Same side (normals point in similar directions): 600mm
                                minDist = MIN_DISTANCE_PARALLEL;
                            } else {
                                // Flipped - check if anti-parallel (opposite facing)
                                if (dotProduct < -0.9) {
                                    // Anti-parallel (opposite facing): 1200mm
                                    minDist = MIN_DISTANCE_OPPOSITE;
                                } else {
                                    // Parallel but not anti-parallel: 600mm
                                    minDist = MIN_DISTANCE_PARALLEL;
                                }
                            }

                            if (dist < minDist) {
                                violations.push({
                                    type: 'error',
                                    message: `Too close to Wall ${otherIndex + 1} (${Math.round(dist)}mm). Minimum: ${minDist}mm`
                                });
                            }
                        }
                    }
                    // Rule 3b: Perpendicular walls have no minimum distance requirement
                }
                
                // DIFFERENT FLOOR RULES (Rule 2)
                else if (onAdjacentFloors) {
                    // Check if walls are parallel and overlapping
                    if (wall.isParallelTo(otherWall)) {
                        const dist = wall.distanceToWall(otherWall);
                        
                        // If overlapping (aligned on same line)
                        if (dist < 10 && wall.overlapsInProjection(otherWall)) {
                            // Rule 2: Overlapping segments must share orientation and thickness
                            if (!wall.sameOrientation(otherWall)) {
                                violations.push({
                                    type: 'error',
                                    message: `Overlapping wall on different floor (Wall ${otherIndex + 1}) must share orientation`
                                });
                            }

                            if (wall.thickness !== otherWall.thickness) {
                                violations.push({
                                    type: 'error',
                                    message: `Overlapping wall on different floor (Wall ${otherIndex + 1}) must share thickness`
                                });
                            }
                        }
                    }
                    // No distance restrictions between floors for non-overlapping walls
                }
            });

            return violations;
        }

        function validateAllWalls() {
            const allViolations = [];
            
            walls.forEach((wall, idx) => {
                const violations = validateWall(wall, idx);
                if (violations.length > 0) {
                    allViolations.push({
                        wallIndex: idx,
                        violations: violations
                    });
                }
            });

            displayViolations(allViolations);
            draw();
        }

        function displayViolations(allViolations) {
            const violationsList = document.getElementById('violationsList');
            
            if (allViolations.length === 0) {
                violationsList.innerHTML = '<div class="no-violations">‚úì All rules satisfied!</div>';
                return;
            }

            let html = '';
            allViolations.forEach(({ wallIndex, violations }) => {
                violations.forEach(v => {
                    html += `
                        <div class="violation-item ${v.type}">
                            <div class="violation-title">Wall ${wallIndex + 1}: ${v.type.toUpperCase()}</div>
                            <div>${v.message}</div>
                        </div>
                    `;
                });
            });

            violationsList.innerHTML = html;
        }

        // Mouse handling
        let currentMousePos = null;

        function getMousePosition(e) {
            const rect = canvas.getBoundingClientRect();
            let x = pxToMm(e.clientX - rect.left);
            let y = pxToMm(e.clientY - rect.top);

            // Always snap to 300mm external grid
            x = snapToGrid(x, GRID_SIZE_EXTERNAL);
            y = snapToGrid(y, GRID_SIZE_EXTERNAL);

            return { x, y };
        }

        function drawSnapIndicator(x, y) {
            // Draw a small circle at snap point
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.arc(mmToPx(x), mmToPx(y), 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw crosshair
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 1;
            const size = 8;
            ctx.beginPath();
            ctx.moveTo(mmToPx(x) - size, mmToPx(y));
            ctx.lineTo(mmToPx(x) + size, mmToPx(y));
            ctx.moveTo(mmToPx(x), mmToPx(y) - size);
            ctx.lineTo(mmToPx(x), mmToPx(y) + size);
            ctx.stroke();
        }

        function setupEventListeners() {
        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePosition(e);
            currentMousePos = pos;

            if (currentMode === 'draw' && drawingWall) {
                // Constrain to horizontal or vertical only
                const dx = Math.abs(pos.x - drawingWall.x);
                const dy = Math.abs(pos.y - drawingWall.y);
                
                if (dx > dy) {
                    // Horizontal wall
                    tempPoint = { x: pos.x, y: drawingWall.y };
                } else {
                    // Vertical wall
                    tempPoint = { x: drawingWall.x, y: pos.y };
                }
            }
            draw();
        });

        canvas.addEventListener('mouseleave', () => {
            currentMousePos = null;
            draw();
        });

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePosition(e);

            if (currentMode === 'draw') {
                if (!drawingWall) {
                    // Start drawing
                    drawingWall = pos;
                    tempPoint = pos;
                } else {
                    // Finish drawing
                    const thickness = parseInt(document.getElementById('wallThickness').value);
                    const height = 2700; // Default height
                    
                    // Constrain to horizontal or vertical
                    const dx = Math.abs(pos.x - drawingWall.x);
                    const dy = Math.abs(pos.y - drawingWall.y);
                    let finalPos = pos;
                    if (dx > dy) {
                        finalPos = { x: pos.x, y: drawingWall.y };
                    } else {
                        finalPos = { x: drawingWall.x, y: pos.y };
                    }
                    
                    const newWall = new Wall(
                        drawingWall.x,
                        drawingWall.y,
                        finalPos.x,
                        finalPos.y,
                        thickness,
                        height
                    );

                    if (newWall.length < MIN_WALL_LENGTH) {
                        alert(`Wall is too short. Minimum length is ${MIN_WALL_LENGTH}mm`);
                        drawingWall = null;
                        tempPoint = null;
                        draw();
                        return;
                    }

                    // Calculate wall segments if longer than MAX_WALL_LENGTH
                    const wallSegments = [];
                    if (newWall.length > MAX_WALL_LENGTH) {
                        const numSegments = Math.ceil(newWall.length / MAX_WALL_LENGTH);
                        const groupId = Date.now() + Math.random(); // Unique ID for this wall group
                        
                        for (let i = 0; i < numSegments; i++) {
                            const startRatio = i / numSegments;
                            const endRatio = (i + 1) / numSegments;
                            
                            let segStart = {
                                x: drawingWall.x + newWall.d.x * startRatio,
                                y: drawingWall.y + newWall.d.y * startRatio
                            };
                            let segEnd = {
                                x: drawingWall.x + newWall.d.x * endRatio,
                                y: drawingWall.y + newWall.d.y * endRatio
                            };
                            
                            // Snap junction points to 100mm grid (columns must be on grid)
                            // First and last points are already snapped (from user drawing)
                            if (i > 0) {
                                segStart.x = snapToGrid(segStart.x, GRID_SIZE_INTERNAL);
                                segStart.y = snapToGrid(segStart.y, GRID_SIZE_INTERNAL);
                            }
                            if (i < numSegments - 1) {
                                segEnd.x = snapToGrid(segEnd.x, GRID_SIZE_INTERNAL);
                                segEnd.y = snapToGrid(segEnd.y, GRID_SIZE_INTERNAL);
                            }
                            
                            wallSegments.push(new Wall(
                                segStart.x, segStart.y,
                                segEnd.x, segEnd.y,
                                thickness,
                                height,
                                groupId, // Assign the same groupId to all segments
                                currentFloorId // Assign to current floor
                            ));
                        }
                    } else {
                        wallSegments.push(newWall);
                    }

                    // Check if any segment is in restricted zone
                    for (let segment of wallSegments) {
                        const restriction = isWallInRestrictedZone(segment);
                        if (restriction.restricted) {
                            alert(`Cannot place wall here. Too close to existing wall.\nMinimum distance required: ${restriction.zone.distance}mm`);
                            drawingWall = null;
                            tempPoint = null;
                            draw();
                            return;
                        }
                    }

                    // Add all segments to walls array
                    wallSegments.forEach(segment => walls.push(segment));
                    
                    drawingWall = null;
                    tempPoint = null;
                    updateUI();
                    validateAllWalls();
                }
            } else if (currentMode === 'select') {
                // Find wall at click position (only on current floor)
                selectedWall = null;
                for (let i = walls.length - 1; i >= 0; i--) {
                    if (walls[i].floorId === currentFloorId && walls[i].containsPoint(pos.x, pos.y)) {
                        selectedWall = walls[i];
                        break;
                    }
                }
                updateUI();
                draw();
            }
        });

        // UI Event handlers
        document.getElementById('drawWallBtn').addEventListener('click', () => {
            currentMode = 'draw';
            drawingWall = null;
            tempPoint = null;
            updateModeUI();
        });

        document.getElementById('selectBtn').addEventListener('click', () => {
            currentMode = 'select';
            drawingWall = null;
            tempPoint = null;
            updateModeUI();
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedWall) {
                const index = walls.indexOf(selectedWall);
                if (index > -1) {
                    walls.splice(index, 1);
                    selectedWall = null;
                    updateUI();
                    validateAllWalls();
                }
            }
        });

        document.getElementById('clearAllBtn').addEventListener('click', () => {
            if (walls.length > 0 && confirm('Are you sure you want to clear all walls?')) {
                walls = [];
                selectedWall = null;
                drawingWall = null;
                tempPoint = null;
                updateUI();
                draw();
            }
        });

        document.getElementById('showGrid').addEventListener('change', draw);
        document.getElementById('showRestrictedZones').addEventListener('change', draw);

        document.getElementById('wallThickness').addEventListener('change', () => {
            if (selectedWall) {
                selectedWall.thickness = parseInt(document.getElementById('wallThickness').value);
                selectedWall.updateVectors();
                draw();
                validateAllWalls();
            }
        });
        
        // Floor management event listeners
        document.getElementById('addFloorBtn').addEventListener('click', () => {
            const newFloorId = floors.length;
            const newFloor = {
                id: newFloorId,
                name: `Floor ${newFloorId}`,
                height: newFloorId * 2700
            };
            floors.push(newFloor);
            updateFloorDropdown();
            currentFloorId = newFloorId;
            document.getElementById('currentFloor').value = currentFloorId;
            draw();
        });
        
        document.getElementById('removeFloorBtn').addEventListener('click', () => {
            if (floors.length > 1) {
                const confirmed = confirm(`Remove ${floors[floors.length - 1].name}? All walls on this floor will be deleted.`);
                if (confirmed) {
                    const removedFloorId = floors[floors.length - 1].id;
                    floors.pop();
                    walls = walls.filter(w => w.floorId !== removedFloorId);
                    if (currentFloorId === removedFloorId) {
                        currentFloorId = floors[floors.length - 1].id;
                    }
                    updateFloorDropdown();
                    document.getElementById('currentFloor').value = currentFloorId;
                    draw();
                    validateAllWalls();
                }
            }
        });
        
        document.getElementById('currentFloor').addEventListener('change', (e) => {
            currentFloorId = parseInt(e.target.value);
            selectedWall = null;
            draw();
            validateAllWalls();
        });
        
        document.getElementById('showOtherFloors').addEventListener('change', draw);
        
        // Initialize UI
        updateFloorDropdown();
        updateModeUI();
        updateUI();
        
        // Show initial message
        document.getElementById('violationsList').innerHTML = 
            '<div class="no-violations">Draw walls to start. Click once for start point, move horizontally or vertically, then click for end point.</div>';
        }

        function updateFloorDropdown() {
            const select = document.getElementById('currentFloor');
            select.innerHTML = '';
            floors.forEach(floor => {
                const option = document.createElement('option');
                option.value = floor.id;
                option.textContent = floor.name;
                select.appendChild(option);
            });
            select.value = currentFloorId;
        }

        function updateModeUI() {
            document.querySelectorAll('.tool-buttons .btn-primary').forEach(btn => {
                btn.classList.remove('active');
            });

            if (currentMode === 'draw') {
                document.getElementById('drawWallBtn').classList.add('active');
                canvas.style.cursor = 'crosshair';
            } else if (currentMode === 'select') {
                document.getElementById('selectBtn').classList.add('active');
                canvas.style.cursor = 'pointer';
            }
        }

        function updateUI() {
            document.getElementById('wallCount').textContent = walls.length;
            document.getElementById('selectedInfo').textContent = 
                selectedWall ? `Wall ${walls.indexOf(selectedWall) + 1}` : 'None';

            if (selectedWall) {
                document.getElementById('wallThickness').value = selectedWall.thickness;
            }

            draw();
        }
    </script>
</body>
</html>

